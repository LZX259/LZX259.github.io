{"meta":{"title":"阿毛之家","subtitle":"","description":"个人博客","author":"LZX","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-08-24T11:22:24.342Z","updated":"2023-08-24T11:22:24.342Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-10-13T03:10:40.037Z","updated":"2023-08-24T11:12:59.341Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-08-24T11:21:25.718Z","updated":"2023-08-24T11:21:25.718Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-09-06T10:39:28.852Z","updated":"2023-08-24T11:16:14.142Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-24T11:21:09.483Z","updated":"2023-08-24T11:21:09.483Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"netstat命令详解","slug":"netstat命令详解","date":"2025-05-28T03:27:40.000Z","updated":"2025-05-28T06:16:14.293Z","comments":true,"path":"2025/05/28/netstat命令详解/","link":"","permalink":"http://example.com/2025/05/28/netstat%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"netstat 命令完全指南netstat（Network Statistics）是一个用于监控网络连接、路由表、接口统计等信息的命令行工具。以下是对其功能的详细解析，涵盖常用命令、高级用法及实际场景示例。 目录一、基本语法与常用选项二、核心功能详解三、高级用法与组合命令四、实际场景示例五、跨平台差异与替代工具六、常见问题与技巧 一、基本语法与常用选项1netstat [选项] [间隔时间] 常用选项速查表 选项 功能描述 -a 显示所有连接（包括监听和非监听） -t 仅显示 TCP 协议连接 -u 仅显示 UDP 协议连接 -l 仅显示监听状态的端口 -n 禁用域名解析（显示 IP 和端口号） -p 显示进程 PID 和程序名（需 root 权限） -r 显示路由表信息 -s 按协议统计网络数据包 -c 持续刷新输出（默认间隔 1 秒） -e 显示扩展信息（如接口 MTU） -4&#x2F;-6 仅显示 IPv4 或 IPv6 连接 二、核心功能详解1. 查看所有网络连接1netstat -a 输出列说明: Proto: 协议类型（TCP&#x2F;UDP） Recv-Q&#x2F;Send-Q: 接收&#x2F;发送队列大小 Local Address: 本地地址与端口 Foreign Address: 远程地址与端口 State: 连接状态（如 ESTABLISHED, LISTEN） 2. 过滤 TCP&#x2F;UDP 连接12netstat -at # 仅 TCPnetstat -au # 仅 UDP 3. 显示监听端口1netstat -lntu 组合选项: -l: 仅监听端口 -n: 数字格式 -t&#x2F;-u: 协议过滤 4. 查看进程与网络关联1sudo netstat -tulnp 示例输出:123Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1234/sshd 5. 网络接口统计1netstat -i 关键指标: RX-OK&#x2F;TX-OK: 成功接收&#x2F;发送的数据包 RX-ERR&#x2F;TX-ERR: 错误数据包数量 MTU: 最大传输单元 三、高级用法与组合命令1. 按状态统计 TCP 连接数1netstat -ant | awk &#x27;/^tcp/ &#123;print $6&#125;&#x27; | sort | uniq -c 输出示例:12310 ESTABLISHED 2 LISTEN 1 TIME_WAIT 2. 查找占用特定端口的进程1sudo netstat -tulnp | grep :80 3. 实时监控网络活动1watch -n 1 &quot;netstat -atn | grep ESTABLISHED&quot; 4. 路由表分析1netstat -rn 关键列: Destination: 目标网络 Gateway: 网关地址 Genmask: 子网掩码 Iface: 网络接口 四、实际场景示例场景 1: 诊断端口冲突12345# 查看 8080 端口是否被占用sudo netstat -tulnp | grep :8080# 若发现占用进程，终止该进程kill -9 &lt;PID&gt; 场景 2: 分析网络吞吐量12# 查看接口统计（每秒刷新）netstat -ie 1 场景 3: 追踪异常连接12# 筛选所有处于 SYN_SENT 状态的连接netstat -ant | grep SYN_SENT 五、跨平台差异与替代工具1. 操作系统差异 功能 Linux macOS Windows 显示进程名 -p -v 不支持 持续刷新 -c -w &lt;秒&gt; 无类似参数 2. 替代工具推荐 ss (Linux): 查看文件与网络连接关联1ss -tulnp # 替代 netstat -tulnp lsof: 查看文件与网络连接关联1lsof -i :80 # 查看 80 端口占用情况 六、常见问题与技巧1. TIME_WAIT 状态连接 原因: TCP 正常关闭后的等待状态，确保数据完整性。 解决: 通常无需干预，可通过调整内核参数优化。 2. netstat 与 ss 的选择 优先 ss: 在 Linux 中，ss 直接读取内核数据，速度更快。 3. 统计总连接数命令: netstat -ant | wc -l 4. 过滤特定 IP 的连接命令: netstat -an | grep 192.168.1.100","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"抓包","slug":"抓包","date":"2025-03-26T11:21:01.000Z","updated":"2025-05-28T03:26:37.730Z","comments":true,"path":"2025/03/26/抓包/","link":"","permalink":"http://example.com/2025/03/26/%E6%8A%93%E5%8C%85/","excerpt":"","text":"1.linux环境123456789101112131415161718192021# 命令介绍tcpdump -i eth0 -w tcp.pcap -s 100 -c 10 -n &#x27;host 1.1.1.1 and port 80 and tcp and vlan 10&#x27; # -i: 指定网口 # -w: 保存到文件 # -s: 限制单个包长度 # -c: 指定抓包数量 # -n: 不解析主机名和端口名 # host/src/dst: ip地址 # [src/dst] port: 端口号 # icmp/udp/tcp/sctp # vlan: 限制VLAN抓包 # -v/-vv: 显示详细信息# 常用命令tcpdump -i eth0 icmptcpdump -i eth0 host 1.1.1.1tcpdump -i eth0 host 1.1.1.1 and port 80tcpdump -i eth0 -w tcp.pcaptcpdump -i eth0 -w tcp.pcap host 1.1.1.1tcpdump -i eth0 -w tcp.pcap host 1.1.1.1 and port 80 2.vpp协议栈123456789101112131415161718192021222324252627282930# 1.pcap trace抓包pcap trace rx tx max [num] intfc [interface] file [filename] max-bytes-per-pkt [number] filter [protocol] buffer-size [size] # rx/tx/drop: 接收、发送、丢弃 # num: 捕获的最大包数 # interface: 指定抓包的网络接口 # filename: 保存抓包数据的文件名 # number: 单个包长度 # protocol: 指定过滤协议(tcp/udp/ip/icmp) # size: 缓冲区大小(单位为KB)## 常用命令pcap trace rx tx drop max 10000 intfc TenGigabitEthernet1 file capture.pcap max-bytes-per-pkt 1000 filter tcppcap trace rx max 10000pcap trace tx max 10000pcap trace rx tx max 10000pcap trace rx tx drop max 10000pcap trace status # 查看抓包状态pcap trace off # 结束抓包# 2.pcap dispatch trace抓包pcap dispatch trace on max [num] file [filename] # num: 捕获的最大包数 # filename: 保存抓包数据的文件名## 常用命令pcap dispatch trace on max 10000 file capture.pcappcap dispatch trace statuspcap dispatch trace off 3.镜像抓包1234567891011121314# 以H3C交换机为例system-viewmirroring-group 1 source GigabitEthernet 1/0/1 &#123;direction&#125; # 创建镜像组，编号为1，指定源端口，监控流向(direction: both、inbound、outbound)mirroring-group 1 destination GigabitEthernet 1/0/2 # 指定镜像组1的目的端口display mirroring-group all # 显示所有镜像组的配置信息抓包，在目的端口连接的设备上undo mirroring-group 1 # 取消镜像组配置mirroring-group 1 local # 创建本地镜像组mirroring-group 1 mirroring-port GigabitEthernet 1/0/18 both # 配置本地镜像组1的源端口为GE1/0/1，并镜像端口的双向流量mirroring-group 1 monitor-port GigabitEthernet 1/0/20 # 配置本地镜像目的观察端口为GE1/0/3抓包，在目的端口连接的设备上undo mirroring-group 1 # 取消镜像组配置 4.windos环境 打开wireshark 选择网口，开始抓包 过滤报文 123456789# 过滤指令icmp/tcp/udp/sctp/gtpuip.src/ip.dst/ip.addr/ipv6.src/ipv6.dst/ipv6.addr()/&amp;&amp;/||/!/==# 常用指令icmp || tcpip.addr == 1.1.1.1ip.src == 1.1.1.1 &amp;&amp; ip.dst == 2.2.2.2 4.1 抓包过滤器捕获过滤器的菜单栏路径为Capture –&gt; Capture Filters。用于在抓取数据包前设置。 类型Type（host、net、port） 方向Dir（src、dst） 协议Proto（ether、ip、tcp、udp、http、icmp、ftp等） 逻辑运算符（&amp;&amp; 与、|| 或、！非） 协议过滤： 直接在抓包过滤框中直接输入协议名即可。IP过滤： src host 192.168.1.104端口过滤： src port 80逻辑运算符： &amp;&amp; 与、|| 或、！非 4.2 显示过滤器显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。 比较操作符： 有&#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt;&#x3D; 大于等于、&lt;&#x3D;小于等于。协议过滤： 直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。ip过滤： ip.src &#x3D;&#x3D;192.168.1.104端口过滤： tcp.srcport &#x3D;&#x3D; 80Http模式过滤： http.request.method&#x3D;&#x3D;“GET”, 只显示HTTP GET方法的。逻辑运算符： and&#x2F;or&#x2F;not","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"top命令详解","slug":"top命令详解","date":"2025-02-28T06:05:26.000Z","updated":"2025-02-28T07:03:38.852Z","comments":true,"path":"2025/02/28/top命令详解/","link":"","permalink":"http://example.com/2025/02/28/top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"top 命令使用详解top 是 Linux 系统中用于实时监控系统资源使用情况和进程状态的强大工具。以下是对其使用方法的详细解析： 一、基本用法直接输入 top 即可启动，界面分为两部分： 上半部分：系统概况（CPU、内存、交换分区、运行时间等）。 下半部分：进程列表（默认按 CPU 使用率排序）。 二、关键界面信息解读1. 系统概况区 第一行： 当前时间、系统运行时间（up ...）、登录用户数（users）。 负载平均值（load average）：1分钟、5分钟、15分钟的平均负载（超过 CPU 核数表示高负载）。 第二行（Tasks）： 总进程数、运行中（running）、休眠（sleeping）、停止（stopped）、僵尸进程（zombie）。 第三行（CPU）： us（用户空间占用）、sy（内核空间占用）、ni（优先级进程占用）、id（空闲）、wa（I&#x2F;O等待）、hi（硬件中断）、si（软件中断）、st（虚拟机占用）。 第四行（内存）： total（总量）、free（空闲）、used（已用）、buff/cache（缓存）。 第五行（交换分区）： 类似内存信息，交换分区使用情况。 2. 进程列表区 PID：进程 ID。 USER：进程所有者。 PR（优先级）、NI（Nice 值）。 VIRT：虚拟内存总量（KB）。 RES：实际物理内存使用量（KB）。 SHR：共享内存大小（KB）。 %CPU：CPU 使用率（**单核满负载为 100%**）。 %MEM：内存使用率。 TIME+：累计 CPU 时间。 COMMAND：启动命令。 三、常用交互式命令1. 排序 P（默认）：按 CPU 使用率排序。 M：按内存使用率排序。 T：按运行时间排序。 N：按 PID 排序。 R：反向排序（配合排序键使用）。 2. 显示控制 k：终止进程（需输入 PID）。 f：自定义显示列（按空格选择&#x2F;取消）。 z：切换颜色主题。 c：显示完整命令路径。 1：展开 CPU 核心的详细使用情况。 h：查看帮助。 3. 刷新与退出 s：修改刷新间隔（秒）。 q：退出 top。 四、启动参数（命令行选项）基础参数 -d &lt;秒&gt;：设置刷新间隔（如 top -d 5）。 -p &lt;PID&gt;：仅监控指定进程（如 top -p 1234）。 -u &lt;用户&gt;：仅显示指定用户的进程（如 top -u root）。 -b：批处理模式（输出到文件，如 top -b -n 3 &gt; top.log）。 -n &lt;次数&gt;：指定刷新次数后退出（配合 -b 使用）。 高级参数 -H：显示线程（需在界面中按 H 切换）。 -i：忽略空闲进程。 五、实战示例1. 监控指定用户的进程1top -u apache 2. 记录系统状态到文件1top -b -n 5 &gt; system_status.log 3. 仅监控 CPU 密集型进程启动 top 后按 P，观察 %CPU 列。 六、启动参数（命令行选项） 僵尸进程：若发现大量 zombie 进程，需检查父进程是否正常回收资源。 高负载处理：负载持续过高时，结合 vmstat 或 iostat 分析 I/O 或 CPU 瓶颈。 内存泄漏：RES 持续增长的进程可能存在内存泄漏。 七、替代工具推荐 htop：交互更友好，支持鼠标操作（需安装）。 glances：综合监控工具，支持多服务器。","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"协议解析","slug":"协议解析","date":"2025-02-24T06:42:32.000Z","updated":"2025-02-28T06:06:51.358Z","comments":true,"path":"2025/02/24/协议解析/","link":"","permalink":"http://example.com/2025/02/24/%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"1. IP 协议1.1 IPv4 固定字段 字段名称 位数（比特） 描述 Version 4 IP版本号，固定为 4（表示IPv4）。 IHL 4 头部长度（以32位字为单位），最小值为 5（对应20字节无选项）。 Type of Service 8 服务类型（优先级、延迟、吞吐量等，现用DSCP&#x2F;ECN替代）。 Total Length 16 整个IP包的总长度（头部+数据），最大为 65535字节。 Identification 16 数据包唯一标识符，用于分片重组。 Flags 3 分片标志： - 第1位：保留； - 第2位：DF（禁止分片）； - 第3位：MF（更多分片）。 Fragment Offset 13 分片偏移量（以8字节为单位），用于重组原始数据包。 Time to Live 8 生存时间（TTL），每经过一个路由器减1，归零时丢弃。 Protocol 8 上层协议类型（如 6&#x3D;TCP，17&#x3D;UDP）。 Header Checksum 16 头部校验和，仅校验IP头部完整性。 Source Address 32 源IPv4地址（4字节，如 192.168.1.1）。 Destination Address 32 目标IPv4地址（4字节，如 192.168.1.2）。 1.2 IPv6 固定字段 字段名称 位数（比特） 描述 Version 4 IP版本号，固定为 6（表示IPv6）。 Traffic Class 8 流量类别（用于QoS优先级，类似IPv4的TOS，支持DSCP&#x2F;ECN）。 Flow Label 20 流标签（标识同一数据流的包，用于QoS或实时流量管理）。 Payload Length 16 有效载荷长度（扩展头部+数据部分的总字节数，最大 65535字节）。 Next Header 8 下一个头部类型（类似IPv4的协议字段，或指向扩展头部类型）。 Hop Limit 8 跳数限制（类似IPv4的TTL，每经过一个路由器减1，归零时丢弃）。 Source Address 128 源IPv6地址（16字节，如 2001:db8::1）。 Destination Address 128 目标IPv6地址（16字节，如 2001:db8::2）。 2. TCP协议 字段名称 位数（比特） 描述 Source Port 16 源端口号（范围：0-65535）。 Destination Port 16 目标端口号（范围：0-65535）。 Sequence Number 32 序列号（标识数据段的顺序，用于重组和可靠性传输）。 Acknowledgment Number 32 确认号（期望接收的下一个序列号，仅在 ACK 标志为1时有效）。 Data Offset 4 TCP头部长度（以32位字为单位），最小值为 5（对应20字节无选项）。 Reserved 4 保留位（必须设为 0）。 Control Flags 6 控制标志（1位&#x2F;标志）： - URG（紧急指针有效）； - ACK（确认号有效）； - PSH（接收方应立即推送数据）； - RST（重置连接）； - SYN（同步建立连接）； - FIN（终止连接）。 Window Size 16 接收窗口大小（流量控制，表示可接收的数据量）。 Checksum 16 校验和（覆盖TCP头部、数据和伪头部）。 Urgent Pointer 16 紧急指针（仅在 URG=1 时有效，指向紧急数据的末尾偏移量）。 3. UDP协议 字段名称 位数（比特） 描述 Source Port 16 源端口号（范围：0-65535），可选（若未使用则置为 0）。 Destination Port 16 目标端口号（范围：0-65535）。 Length 16 UDP数据报总长度（头部 + 数据），最小为 8字节（仅头部无数据）。 Checksum 16 校验和（覆盖UDP头部、数据和伪头部，若未使用则置为 0）。 4. SCTP协议公共头部 字段名称 位数（比特） 描述 Source Port 16 源端口号（范围：0-65535）。 Destination Port 16 目标端口号（范围：0-65535）。 Verification Tag 32 验证标签（用于关联数据包与连接）。 Checksum 32 校验和（覆盖整个SCTP数据包）。 （1）DATA Chunk（正常数据，类型 0x00） 字段名称 位数（比特） 描述 Chunk Type 8 固定为 0x00（标识为DATA Chunk）。 Chunk Flags 8 控制标志：- U（Unordered，无序交付，1&#x3D;启用）；- B（Beginning，首分片，1&#x3D;数据起始）；- E（Ending，末分片，1&#x3D;数据结束）；- 其余位保留（设为0）。 Chunk Length 16 DATA Chunk总长度（单位：字节），包含头部、数据及可能的填充。 TSN 32 传输序列号（Transmission Sequence Number），唯一标识数据块。 Stream Identifier 16 流标识符（Stream ID），标识数据所属的流。 Stream Sequence Number 16 流内序列号（Stream Sequence Number），标识流内数据的顺序。 Payload Protocol Identifier 32 负载协议标识符（PPID），标识上层协议类型（如HTTP、SIP等）。 Payload Data 可变 实际用户数据（长度由Chunk Length计算得出）。 Padding 可变（0-3B） 填充字节（可选），确保整个Chunk长度为4字节对齐。 （2）INIT Chunk（初始化连接，类型 0x01） 字段名称 位数（比特） 描述 Initiate Tag 32 发起方验证标签（用于后续数据包验证）。 Advertised Receiver Window Credit (a_rwnd) 32 接收窗口大小（初始流量控制参数）。 Number of Outbound Streams 16 发起方支持的最大出站流数量。 Number of Inbound Streams 16 发起方支持的最大入站流数量。 Initial TSN 32 初始传输序列号（TSN起始值）。 Optional Parameters 可变 可选参数（如支持的地址列表、Cookie Preservative等）。 （3）INIT ACK Chunk（初始化确认，类型 0x02） 字段名称 位数（比特） 描述 Initiate Tag 32 响应方生成的验证标签。 Advertised Receiver Window Credit (a_rwnd) 32 响应方的接收窗口大小。 Number of Outbound Streams 16 响应方支持的最大出站流数量。 Number of Inbound Streams 16 响应方支持的最大入站流数量。 Initial TSN 32 响应方初始传输序列号。 State Cookie 可变 包含连接状态信息的Cookie（防攻击）。 Optional Parameters 可变 可选参数（如地址列表扩展）。 （4）SACK Chunk（选择性确认，类型 0x03） 字段名称 位数（比特） 描述 Cumulative TSN Ack 32 已确认的最高连续TSN。 Advertised Receiver Window Credit (a_rwnd) 32 更新后的接收窗口大小。 Number of Gap Ack Blocks 16 非连续确认块的数量（标识已接收的非连续TSN范围）。 Number of Duplicate TSNs 16 重复接收的TSN数量（用于检测丢包或重复）。 Gap Ack Blocks 可变 非连续确认块列表（每个块由起始和结束偏移量表示）。 Duplicate TSNs 可变 重复接收的TSN列表。 （5）HEARTBEAT &#x2F; HEARTBEAT ACK Chunk（心跳检测，类型 0x04&#x2F;0x05） 字段名称 位数（比特） 描述 Cumulative TSN Ack 32 已确认的最高连续TSN。 Advertised Receiver Window Credit (a_rwnd) 32 更新后的接收窗口大小。 Number of Gap Ack Blocks 16 非连续确认块的数量（标识已接收的非连续TSN范围）。 Number of Duplicate TSNs 16 重复接收的TSN数量（用于检测丢包或重复）。 Gap Ack Blocks 可变 非连续确认块列表（每个块由起始和结束偏移量表示）。 Duplicate TSNs 可变 重复接收的TSN列表。 （6）ABORT Chunk（终止连接，类型 0x06） 字段名称 位数（比特） 描述 Error Causes 可变 终止原因（如协议错误、资源不足等）。 （7）SHUTDOWN Chunk（优雅关闭，类型 0x07） 字段名称 位数（比特） 描述 Cumulative TSN Ack 32 已确认的最高连续TSN（用于关闭前的数据确认）。 （8）ERROR Chunk（错误通知，类型 0x09） 字段名称 位数（比特） 描述 Error Causes 可变 错误原因列表（如无效流ID、Cookie过期等）。 5. GTP-U协议 字段名称 位数（比特） 描述 Version 3 版本号（GTPv1-U为 1）。 Protocol Type 1 协议类型（1&#x3D;GTP，0&#x3D;GTP’）。 REserved 1 保留字段。 E 1 扩展头标志（1&#x3D;存在扩展头，0&#x3D;无扩展头）。 S 1 序列号标志（1&#x3D;包含序列号字段）。 PN 1 N-PDU号标志（1&#x3D;包含N-PDU号字段）。 Message Type 8 消息类型（如 0xFF&#x3D;G-PDU，0x01&#x3D;Echo Request）。 Length 16 消息总长度（不包括前8字节）。 TEID 32 隧道端点标识符（标识用户数据所属的隧道）。 Sequence Number 16 序列号（可选，当 S=1 时存在）。 N-PDU Number 8 N-PDU编号（可选，当 PN=1 时存在）。 Extension Header 8 扩展头数目（可选，仅当 Extension Flag&#x3D;1 时存在，后接扩展头内容） Payload 可变 封装的用户数据（如 IP 包）","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"git命令","slug":"git命令","date":"2024-11-18T06:24:26.000Z","updated":"2025-02-28T06:52:05.958Z","comments":true,"path":"2024/11/18/git命令/","link":"","permalink":"http://example.com/2024/11/18/git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令123456789101112131415161718192021222324252627282930313233343536git clone ssh://230700089@192.168.53.31:29418/nr-trp # 克隆代码git pull origin master # 拉取代码git log # 查看日志git reset # 撤销本地更改git reset 45b6620eb4387f4173b68921128e9dd8fbcd4c7f # 恢复到某一节点git diffgit diff &gt; backup.patch # 将差异保存为patchgit checkout &#123;filename&#125; # 将指定文件恢复到本地仓库最新节点版本git config --global --list # 查看当前git的配置信息git rm --cached &#123;filename&#125; # 将文件移除缓冲区# 提交文件git pull origin master # 拉取代码git checkout &#123;filename&#125; # 将指定文件恢复到本地仓库最新节点版本git status # 查看文件状态git add &#123;filename&#125;git add . # 添加当前路径下所有改动的文件到git commit -m &quot;descripe&quot; # 添加提交日志git commit -a -m &quot;descripe&quot; # 修改上次提交日志git push origin HEAD:refs/for/master # 审核提交git push origin master # 直接提交# stashgit stash -u # 包括未跟踪的文件（如新建文件）git stash save &quot;备注信息&quot; # 将“工作目录”和“暂存区”的改动保存到“储藏区”git stash list # 查看所有储藏记录git stash pop # 恢复最近一次储藏git stash apply stash@&#123;n&#125; # 恢复指定储藏（不删除记录）git stash drop stash@&#123;n&#125; # 删除某条储藏记录git stash clear # 清空所有储藏记录（谨慎使用）# 添加子仓库git remote show origin # 查看远程仓库的地址git submodule add &lt;url&gt; themes/volantis # 添加子仓库git rm -r --cached themes_origin/hexo-theme-volantis # 将文件从索引中移除git submodule add https://github.com/volantis-x/hexo-theme-volantis.git themes_origin/hexo-theme-volantis/","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"华三交换机命令","slug":"华三交换机命令","date":"2024-11-18T06:14:54.000Z","updated":"2024-11-18T06:35:50.965Z","comments":true,"path":"2024/11/18/华三交换机命令/","link":"","permalink":"http://example.com/2024/11/18/%E5%8D%8E%E4%B8%89%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令1234567891011121314151617181920212223display current-configuration // 显示当前配置display interfaces // 显示接口信息displaydisplay version // 显示版本信息system-view // 进入系统视图interface GigabitEthernet1/0/2 // 进入接口视图interface Vlan-interface1 // 进入VLAN接口视图port link-type hybrid // 混合模式port hybrid vlan 124 tagged // 配置Hybrid类型接口加入的VLAN，这些VLAN的帧以Tagged方式通过接口 // undo port hybrid vlan 124 || port hybrid vlan 124 untagged // 缺省，Hybrid端口以untagged方式加入VLAN 1 // 不可用于已经加入Eth-Trunk的物理接口 // 不能使用本命令将接口加入super类型的VLAN port hybrid pvid vlan 124 // 设置Hybrid类型接口的缺省VLAN ID // undo port hybrid pvid vlan 124 // 缺省，所有接口的缺省VLAN为VLAN 1 ip address 192.169.46.2 24 // 配置IPip route-static 10.161.0.0 18 10.161.26.1 // 配置路由","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-11-15T06:39:29.081Z","updated":"2023-08-08T08:29:36.633Z","comments":true,"path":"2024/11/15/hello-world/","link":"","permalink":"http://example.com/2024/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"iptable","slug":"iptable","date":"2024-08-30T02:30:45.000Z","updated":"2024-08-30T03:08:08.055Z","comments":true,"path":"2024/08/30/iptable/","link":"","permalink":"http://example.com/2024/08/30/iptable/","excerpt":"","text":"1. 特点iptables 是 Linux 防火墙工作在用户空间的管理工具，是 netfilter&#x2F;iptablesIP 信息包过滤系统是一部分，用来设置、维护和检查 Linux 内核的 IP 数据包过滤规则。 iptables 是基于内核的防火墙，功能非常强大；iptables 内置了filter，nat和mangle三张表。所有规则配置后，立即生效，不需要重启服务。 2. 四表1234567891011121314151617filter 包过滤 INPUT、OUTPUT、FORWARD 对数据包进行过滤，根据具体的规则决定是否放行该数据包（如DROP、ACCEPT、REJECT、LOG）nat 网络地址转换 PREROUTING、OUTPUT、POSTROUTING 修改数据包的IP地址、端口号等信息（网络地址转换，如SNAT、DNAT、MASQUERADE、REDIRECT）mangle 包重构 PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING 修改数据包的TOS（Type Of Service，服务类型）、TTL（Time To Live，生存周期）指以及为数据包设置Mark标记raw 数据跟踪处理 PREROUTING、OUTPUT 决定数据包是否被状态跟踪机制处理。优先级：raw &gt; mangle &gt; nat &gt; filter 3. 五链12345input 匹配目标IP是本机的数据包output 出口数据包 ， 一般不在此链上做配置forward 匹配流经本机的数据包prerouting 修改目的地址，用来做 DNAT 。如：把内网中的 80 端口映射到互联网端口postrouting 修改源地址，用来做 SNAT。如：局域网共享一个公网 IP 接入 Internet 4. 数据包的四种状态1234NEW 该包想要开始一个连接（重新连接或将连接重定向）RELATED 该包是属于某个已经建立的连接所建立的新连接ESTABLISHED 一个数据连接从 NEW 变为 ESTABLISHED，表示连接建立成功，会继续匹配这个连接的后续数据包INVALID 数据包不能被识别属于哪个连接或没有任何状态比如内存溢出，收到不知属于哪个连接的ICMP错误信息，一般应该DROP这个状态的任何数据","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]},{"title":"传输基础功能测试（PTP模式）","slug":"传输基础功能测试（PTP模式）","date":"2024-08-08T02:44:44.000Z","updated":"2024-11-18T02:58:09.524Z","comments":true,"path":"2024/08/08/传输基础功能测试（PTP模式）/","link":"","permalink":"http://example.com/2024/08/08/%E4%BC%A0%E8%BE%93%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%88PTP%E6%A8%A1%E5%BC%8F%EF%BC%89/","excerpt":"","text":"1. 测试场景说明共四种场景：非BOND非共IP、非BOND共IP、BOND非共IP、BOND共IP。（1）BOND：指的是接口主备模式（2）共IP：指的是PTP时钟链路与SCTP链路本段使用同一个IP 版本：arm版本不支持BOND模式，只包含前两种测试场景；x86版本包含所有测试场景。 基本要求：运行&#x2F;opt&#x2F;lte_health_check &amp;，建小区，跑业务。(5801: nohup &#x2F;opt&#x2F;lte_health_check &amp;) 2. 测试场景2.1 建小区的必须配置添加配置（以3801-230为例）： 12345678910MOD MCB: ShNum=&quot;0&quot;,ChNum=&quot;0&quot;,SlNum=&quot;7&quot;,ConfigState=&quot;Configured&quot;,AdminState=&quot;UnLocked&quot;,memMinorFaultVal=&quot;75&quot;,memMajorFaultVal=&quot;85&quot;,memSeriousFaultVal=&quot;95&quot;,cpuMinorFaultVal=&quot;75&quot;,cpuMajorFaultVal=&quot;85&quot;,cpuSeriousFaultVal=&quot;95&quot;,tempNcThreshd=&quot;95&quot;,tempCrThreshd=&quot;100&quot;,tempNrThreshd=&quot;105&quot;;ADD BPB: ShNum=&quot;0&quot;,ChNum=&quot;0&quot;,SlNum=&quot;2&quot;,Poweron=&quot;PowerOn&quot;,ConfigState=&quot;Configured&quot;,AdminState=&quot;UnLocked&quot;,BPBType=&quot;LBP&quot;,tempNcThreshd=&quot;95&quot;,tempCrThreshd=&quot;100&quot;,tempNrThreshd=&quot;105&quot;;ADD LBPCfg: slNum=&quot;2&quot;,cpriClockSrc=&quot;BACK_BOARD&quot;,partnerId=&quot;YQF_Server&quot;,rruType=&quot;RRU_H&quot;;ADD RRULINK: rruCN=&quot;20&quot;,hShNum=&quot;0&quot;,hChNum=&quot;0&quot;,hSlNum=&quot;2&quot;,hPN=&quot;1&quot;,carrierNum=&quot;1&quot;;ADD RRU: shNum = 0 , chNum = 61 , slNum = 0 , rruName = &quot;11&quot; , rruType = &quot;RRU_H&quot; , powerState = &quot;PowerOn&quot; , configState = &quot;Configured&quot; , adminState = &quot;UnLocked&quot; , boardDesc = &quot;11&quot; , vswr1Thrhld = 30 , vswr2Thrhld = 20 , tempUPTHRHLD = 95 , tempDownTHRHLD = -40 , cpuCalcPriod = 120 , cascadeID = 1 , rruCN = 20 , rruWorkMode = &quot;FDD_LTE&quot; , rxChNum = 2 , txChNum = 2 , accessDirection = &quot;CONNECTHEAD&quot; , transPwrLimit = 32767 , ch1BlockSwitch = &quot;UNBLOCK&quot; , ch2BlockSwitch = &quot;UNBLOCK&quot; , ch3BlockSwitch = &quot;UNBLOCK&quot; , ch4BlockSwitch = &quot;UNBLOCK&quot; , ch5BlockSwitch = &quot;UNBLOCK&quot; , ch6BlockSwitch = &quot;UNBLOCK&quot; , ch7BlockSwitch = &quot;UNBLOCK&quot; , ch8BlockSwitch = &quot;UNBLOCK&quot; ;ADD ANTGROUP: antGroupNo=&quot;2&quot;,antCount=&quot;2ANT&quot;,ant1shNum=&quot;0&quot;,ant1chNum=&quot;61&quot;,ant1slNum=&quot;0&quot;,ant1Port=&quot;R0A&quot;,ant1TRXMode=&quot;TXRX_MODE&quot;,ant2shNum=&quot;0&quot;,ant2chNum=&quot;61&quot;,ant2slNum=&quot;0&quot;,ant2Port=&quot;R0B&quot;,ant2TRXMode=&quot;TXRX_MODE&quot;;ADD SECTOR: sectorID=&quot;1&quot;,sectorMode=&quot;AntGroup&quot;,antGroupNum=&quot;1ANTG&quot;,antGroup1=&quot;2&quot;,carrierNum=&quot;1&quot;,maxBandwidth=&quot;BW_N_NULL&quot;;ADD PlmnInfo: PlmnIdx=&quot;0&quot;,mcc=&quot;460&quot;,mnc=&quot;98&quot;,PrimaryPlmnFlag=&quot;TRUE&quot;,CellReservedForOperatorUse=&quot;NOT_RESERVED_FOR_OPERATOR&quot;,PlmnPriority=&quot;0&quot;;ADD Ta : TaIdx = 0 , Tac = 12596 ;MOD EnodebCfg : EnodebId = 230 , EnodebName = &quot;230&quot; ; 先配置传输配置，再添加小区。 配置存在版本差异，当前版本下面二选一： 12ADD Cell: CellId=&quot;230&quot;,SectorId=&quot;1&quot;,PhyCellId=&quot;230&quot;,DuplexingMode=&quot;Fdd&quot;,FrameEdgeOffset=&quot;0&quot;,BandInd=&quot;28&quot;,UlEarfcn=&quot;27435&quot;,DlEarfcn=&quot;9435&quot;,MaxNumRRC=&quot;400&quot;,Bandwidth=&quot;BW_N_50&quot;,AntennaPortsCount=&quot;AN2&quot;,AntennaMode=&quot;2T2R&quot;,CellActiveState=&quot;ACTIVE&quot;,plmnidx=&quot;0&quot;,TaIdx=&quot;0&quot;,TimeAlignmentTimerCommon=&quot;sf1920&quot;,BusinessType=&quot;Normal_Mode&quot;,MaxUeNum=&quot;UE_NUM400&quot;,RruMode=&quot;NORMAL_MODE&quot;,DRXEnable=&quot;FALSE&quot;,RlfDelayTimer=&quot;10000&quot;,HoDelayTimer=&quot;0&quot;,PLMNRBEnable=&quot;FALSE&quot;,PLMNRBTokenPeriodicity=&quot;20&quot;,FreqPriorityEnable=&quot;FALSE&quot;,BlindHoEnable=&quot;FALSE&quot;,CellName=&quot;230&quot;,VolteDrxEnable=&quot;TRUE&quot;,EplmnEnable=&quot;FALSE&quot;;ADD Cell: CellId=&quot;230&quot;,SectorId=&quot;1&quot;,PhyCellId=&quot;230&quot;,DuplexingMode=&quot;Fdd&quot;,FrameEdgeOffset=&quot;0&quot;,BandInd=&quot;28&quot;,UlEarfcn=&quot;27435&quot;,DlEarfcn=&quot;9435&quot;,MaxNumRRC=&quot;400&quot;,Bandwidth=&quot;BW_N_50&quot;,AntennaPortsCount=&quot;AN2&quot;,AntennaMode=&quot;2T2R&quot;,CellActiveState=&quot;ACTIVE&quot;,plmnidx=&quot;0&quot;,TaIdx=&quot;0&quot;,TimeAlignmentTimerCommon=&quot;sf1920&quot;,BusinessType=&quot;Normal_Mode&quot;,MaxUeNum=&quot;UE_NUM400&quot;,RruMode=&quot;NORMAL_MODE&quot;,DRXEnable=&quot;FALSE&quot;,RlfDelayTimer=&quot;10000&quot;,HoDelayTimer=&quot;0&quot;,PLMNRBEnable=&quot;FALSE&quot;,PLMNRBTokenPeriodicity=&quot;20&quot;,FreqPriorityEnable=&quot;FALSE&quot;,BlindHoEnable=&quot;FALSE&quot;,CellName=&quot;230&quot;; 2.2 非BOND非共IP不配置BOND口，PTP与SCTP链路使用各自的DEVIP，建小区。 添加配置（以3801-230为例）： 1234567891011ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;172.31.100.243&quot;,MASK=&quot;255.255.255.248&quot;,VLAN=&quot;31&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;172.19.5.250&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;172.31.100.241&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;ETH&quot;,vlan=&quot;31&quot;,descri=&quot;description&quot;;ADD SIGPLANEHOST: SPHOSTID=&quot;0&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PORTNUM=&quot;36422&quot;,HBINTER=&quot;2000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;1000&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;;ADD USERPLANEHOST: UPHOSTID=&quot;0&quot;,UPIPADDR=&quot;192.168.2.230&quot;,mode=&quot;DEFAULT_MODE&quot;;ADD SCTPLINK: SCTPID=&quot;1&quot;,LINKTYPE=&quot;ASSOC_TYPE_S1_MASTER&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PEERIP=&quot;192.169.100.81&quot;,SECPEERIP=&quot;0.0.0.0&quot;,PEERPORT=&quot;36412&quot;,HBINTER=&quot;1000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;400&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;,DESCRIPTION=&quot;SCTPLINK&quot;,ACTIVESTATE=&quot;ENABLE&quot;;ADD S1Interface: S1InterfaceId=&quot;1&quot;,S1AssocId=&quot;1&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;31&quot;,ptpDomain=&quot;127&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;172.19.5.250&quot;,EthPort=&quot;ETH&quot;;MOD ClkSwitch: ClkSrcSelectSwitch=&quot;UserConfig&quot;,ClockSrc=&quot;PTP&quot;,HoldOverThreshold=&quot;2&quot;; 删除配置： 12345678DEL S1Interface : S1InterfaceId = 1 , S1AssocId = 1 ;DEL SCTPLINK: SCTPID=&quot;1&quot;;DEL SIGPLANEHOST: SPHOSTID=&quot;0&quot;;DEL USERPLANEHOST: UPHOSTID=&quot;0&quot;;DEL IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;;DEL IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;172.19.5.250&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;172.31.100.241&quot;;DEL DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;DEL DEVIP: PN=&quot;ETH&quot;,IP=&quot;172.31.100.243&quot;,MASK=&quot;255.255.255.248&quot;,VLAN=&quot;31&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;; 2.3 非BOND共IP不配置BOND口，PTP时钟链路与SCTP链路使用同一个DEVIP，建小区。 添加配置： 12345678910ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;192.169.100.110&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;192.168.2.99&quot;,pref=&quot;10&quot;,port=&quot;ETH&quot;,vlan=&quot;124&quot;,descri=&quot;description&quot;;ADD SIGPLANEHOST: SPHOSTID=&quot;0&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PORTNUM=&quot;36422&quot;,HBINTER=&quot;2000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;1000&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;;ADD USERPLANEHOST: UPHOSTID=&quot;0&quot;,UPIPADDR=&quot;192.168.2.230&quot;,mode=&quot;DEFAULT_MODE&quot;;ADD SCTPLINK: SCTPID=&quot;1&quot;,LINKTYPE=&quot;ASSOC_TYPE_S1_MASTER&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PEERIP=&quot;192.169.100.81&quot;,SECPEERIP=&quot;0.0.0.0&quot;,PEERPORT=&quot;36412&quot;,HBINTER=&quot;1000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;400&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;,DESCRIPTION=&quot;SCTPLINK&quot;,ACTIVESTATE=&quot;ENABLE&quot;;ADD S1Interface: S1InterfaceId=&quot;1&quot;,S1AssocId=&quot;1&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;124&quot;,ptpDomain=&quot;4&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;192.169.100.110&quot;,EthPort=&quot;ETH&quot;;MOD ClkSwitch: ClkSrcSelectSwitch=&quot;UserConfig&quot;,ClockSrc=&quot;PTP&quot;,HoldOverThreshold=&quot;2&quot;; 删除配置： 1234567DEL S1Interface : S1InterfaceId = 1 , S1AssocId = 1 ;DEL SCTPLINK: SCTPID=&quot;1&quot;;DEL SIGPLANEHOST: SPHOSTID=&quot;0&quot;;DEL USERPLANEHOST: UPHOSTID=&quot;0&quot;;DEL IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;;DEL IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;192.169.100.110&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;192.168.2.99&quot;;DEL DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;; 2.4BOND 非共IP配置BOND口，PTP与SCTP链路使用各自的DEVIP，建小区。 添加配置： 123456789101112ADD BOND: ac_port=&quot;SFP1&quot;,bc_port=&quot;ETH&quot;,priority=&quot;Disable&quot;;ADD DEVIP: PN=&quot;BOND&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD DEVIP: PN=&quot;BOND&quot;,IP=&quot;172.31.100.243&quot;,MASK=&quot;255.255.255.248&quot;,VLAN=&quot;31&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;172.19.5.250&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;172.31.100.241&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;BOND&quot;,vlan=&quot;31&quot;,descri=&quot;description&quot;;ADD SIGPLANEHOST: SPHOSTID=&quot;0&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PORTNUM=&quot;36422&quot;,HBINTER=&quot;2000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;1000&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;;ADD USERPLANEHOST: UPHOSTID=&quot;0&quot;,UPIPADDR=&quot;192.168.2.230&quot;,mode=&quot;DEFAULT_MODE&quot;;ADD SCTPLINK: SCTPID=&quot;1&quot;,LINKTYPE=&quot;ASSOC_TYPE_S1_MASTER&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PEERIP=&quot;192.169.100.81&quot;,SECPEERIP=&quot;0.0.0.0&quot;,PEERPORT=&quot;36412&quot;,HBINTER=&quot;1000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;400&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;,DESCRIPTION=&quot;SCTPLINK&quot;,ACTIVESTATE=&quot;ENABLE&quot;;ADD S1Interface: S1InterfaceId=&quot;1&quot;,S1AssocId=&quot;1&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;31&quot;,ptpDomain=&quot;127&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;172.19.5.250&quot;,EthPort=&quot;BOND&quot;;MOD ClkSwitch: ClkSrcSelectSwitch=&quot;UserConfig&quot;,ClockSrc=&quot;PTP&quot;,HoldOverThreshold=&quot;2&quot;; 删除配置： 123456789DEL S1Interface : S1InterfaceId = 1 , S1AssocId = 1 ;DEL SCTPLINK: SCTPID=&quot;1&quot;;DEL SIGPLANEHOST: SPHOSTID=&quot;0&quot;;DEL USERPLANEHOST: UPHOSTID=&quot;0&quot;;DEL IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;;DEL IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;172.19.5.250&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;172.31.100.241&quot;;DEL DEVIP: PN=&quot;BOND&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;DEL DEVIP: PN=&quot;BOND&quot;,IP=&quot;172.31.100.243&quot;,MASK=&quot;255.255.255.248&quot;,VLAN=&quot;31&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;DEL BOND: ac_port=&quot;SFP1&quot;,bc_port=&quot;ETH&quot;; 2.5 BOND共IP配置BOND口，PTP与SCTP链路使用同一个DEVIP，建小区。 添加配置： 1234567891011ADD BOND: ac_port=&quot;SFP1&quot;,bc_port=&quot;ETH&quot;,priority=&quot;Disable&quot;;ADD DEVIP: PN=&quot;BOND&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;192.169.100.110&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;BOND&quot;,vlan=&quot;124&quot;,descri=&quot;description&quot;;ADD SIGPLANEHOST: SPHOSTID=&quot;0&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PORTNUM=&quot;36422&quot;,HBINTER=&quot;2000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;1000&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;;ADD USERPLANEHOST: UPHOSTID=&quot;0&quot;,UPIPADDR=&quot;192.168.2.230&quot;,mode=&quot;DEFAULT_MODE&quot;;ADD SCTPLINK: SCTPID=&quot;1&quot;,LINKTYPE=&quot;ASSOC_TYPE_S1_MASTER&quot;,LOCIP=&quot;192.168.2.230&quot;,SECLOCIP=&quot;0.0.0.0&quot;,PEERIP=&quot;192.169.100.81&quot;,SECPEERIP=&quot;0.0.0.0&quot;,PEERPORT=&quot;36412&quot;,HBINTER=&quot;1000&quot;,MAXPATHRETR=&quot;5&quot;,MAXASSOCRETR=&quot;6&quot;,RTOINIT=&quot;200&quot;,RTOMAX=&quot;400&quot;,RTOMIN=&quot;200&quot;,COOKIELIFE=&quot;60000&quot;,INITMAXATTEMPTS=&quot;8&quot;,INITMAXTIMEO=&quot;0&quot;,MAXINSTREAM=&quot;10&quot;,MAXOUTSTREAM=&quot;10&quot;,DESCRIPTION=&quot;SCTPLINK&quot;,ACTIVESTATE=&quot;ENABLE&quot;;ADD S1Interface: S1InterfaceId=&quot;1&quot;,S1AssocId=&quot;1&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;124&quot;,ptpDomain=&quot;4&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;192.169.100.110&quot;,EthPort=&quot;ETH&quot;;MOD ClkSwitch: ClkSrcSelectSwitch=&quot;UserConfig&quot;,ClockSrc=&quot;PTP&quot;,HoldOverThreshold=&quot;2&quot;; 删除配置： 12345678DEL S1Interface : S1InterfaceId = 1 , S1AssocId = 1 ;DEL SCTPLINK: SCTPID=&quot;1&quot;;DEL SIGPLANEHOST: SPHOSTID=&quot;0&quot;;DEL USERPLANEHOST: UPHOSTID=&quot;0&quot;;DEL IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;;DEL IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;192.169.100.110&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;192.168.2.99&quot;;DEL DEVIP: PN=&quot;BOND&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;DEL BOND: ac_port=&quot;SFP1&quot;,bc_port=&quot;ETH&quot;; 3. 观察现象（1）SCTPLINK的状态是否UP；（2）PTP时钟状态正常：能同步上是最好；同步不上，在保证PTP链路正常的前提下，切GNSS&#x2F;FreeRun；（3）小区在服；（4）观察UE及灌包情况（15分钟）：UE不掉线，灌包数据正常；（5）存在BOND的情况：交替拔插主备端口，观察UE是否掉线，ping丢包情况（丢一两个包，正常）；（6）检查系统资源使用情况（&#x2F;var&#x2F;log&#x2F;cspl&#x2F;health）。 4. PTP时钟测试4.1 配置非共IP的PTP链路PTP服务器：使用测试部那边的PTP服务器，IP为172.19.5.250。 基站配置： 12345ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;172.31.100.243&quot;,MASK=&quot;255.255.255.248&quot;,VLAN=&quot;31&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;172.19.5.250&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;172.31.100.241&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;ETH&quot;,vlan=&quot;31&quot;,descri=&quot;description&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;31&quot;,ptpDomain=&quot;127&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;172.19.5.250&quot;,EthPort=&quot;ETH&quot;; 4.2配置共IP的PTP链路PTP服务器：打开终端，ssh到我们的核心网，IP为10.161.28.21。执行如下命令运行PTP服务器，IP为192.169.100.110。 12cd /opt/ptp_server/linuxptp./src/ptp4l -f configs/G.8265.1_sample_master.cfg -i eth1 -H -m 基站配置： 1234ADD DEVIP: PN=&quot;ETH&quot;,IP=&quot;192.168.2.230&quot;,MASK=&quot;255.255.255.0&quot;,VLAN=&quot;124&quot;,AddressingType=&quot;Static&quot;,Usage=&quot;S1&quot;;ADD IPROUTE: rt_type=&quot;NET&quot;,dst_ip=&quot;192.169.100.0&quot;,dst_mask=&quot;255.255.255.0&quot;,next_hop=&quot;192.168.2.99&quot;,usage=&quot;S1&quot;,pref=&quot;10&quot;,port=&quot;Auto&quot;,descri=&quot;description&quot;;ADD IPROUTE: rt_type=&quot;HOST&quot;,dst_ip=&quot;192.169.100.110&quot;,dst_mask=&quot;255.255.255.255&quot;,next_hop=&quot;192.168.2.99&quot;,pref=&quot;10&quot;,port=&quot;ETH&quot;,vlan=&quot;124&quot;,descri=&quot;description&quot;;MOD PTP: ptpProtocol=&quot;8275_2&quot;,ptpSyncMode=&quot;frequency&quot;,ptpDscp=&quot;46&quot;,ptpVlanID=&quot;124&quot;,ptpDomain=&quot;4&quot;,ptpAnnouncePeriod=&quot;0&quot;,ptpSyncPeriod=&quot;-1&quot;,ptpAvailServer1Addr=&quot;192.169.100.110&quot;,EthPort=&quot;ETH&quot;; 4.3 观察PTP链路是否正常打开终端，ssh到基站，输入命令bsp ptp4l log打印PTP时钟的实时状态。ppsState为0表示PTP时钟同步。只要打印出时间偏差则表示PTP链路正常，ppsState不为0也没关系。 5. 灌包测试前提条件：小区在服 5.1 UE上线打开QXDM软件，在View -&gt; New -&gt; LTE -&gt; RRC Layer 中打开 LTE RRC State Change Plot 窗口。 在Options 中打开 Communications 窗口，10.161.31.127管理主机连接UE的串口为COM13（参考传输配置表格–管理主机）。 在Command命令窗口执行mode lpm命令和mode online命令，观察 LTE RRC State Change Plot 窗口，应该处于Connected状态。 然后在显示屏右下角点击网络连接图标，连接网络，如果已经连上则不予理会。至此UE已经上线了，可以打开windos cmd终端或者PowerShell终端，执行ipconfig 查看UE的IP。 5.2 UE与灌包服务器之间的网络配置远程到10.161.31.126管理主机，该主机作为灌包服务器，服务器IP为192.168.49.99。需在126和127管理主机上配置路由（参考传输配置表格–管理主机），保证UE与灌包服务器网络能通，两边互相能ping通。Windos终端用到的命令： 1234567查看IP： ipconfigPing包： ping 192.168.49.99 -t查看路由： route print上行路由： route ADD 192.168.49.99 MASK 255.255.255.255 2.2.1.1 METRIC 1 -proute DELETE 192.168.49.99 MASK 255.255.255.255 2.2.1.1 METRIC 1 -p下行路由： route ADD 2.2.2.1 MASK 255.255.255.255 192.168.49.90 METRIC 1 -proute DELETE 2.2.2.1 MASK 255.255.255.255 192.168.49.90 METRIC 1 -p 5.3 开始灌包打开gperf.exe软件，只需要修改目标IP，灌包速率即可。127进行上行灌包，126进行下行灌包。 通过ssh连接到基站，执行如下命令，进入vpp查看ue状态及上下行速率。 123cd /LTE/user/Area0/bin./vppctlshow ue 6. BOND测试前提条件：配置BOND链路，建小区，UE上线。（1）UE与灌包服务器之间一直保持相互ping包的状态；（2）打开终端，ssh到基站，输入如下命令可以看出eth2是BOND的活跃口（哪个口在前面，哪个口就是活跃口）。 123cd /LTE/user/Area0/bin./vppctlshow bond details （3）此时拔插eth2口的网线，执行show bond details命令，可以观察到eth3口成为活跃口，UE没有掉线，两边ping包没有丢包（一两个丢包没关系）；拔插eth3口的网线重复此步骤，重复4~5次，没有异常，则测试通过。 7. 检查系统资源使用情况进行版本测试前，执行命令&#x2F;opt&#x2F;lte_health_check &amp;，把检查系统资源使用情况的程序拉起来；每个用例测试结束后，去查看lteDiskFullDetail.txt、lteMemReport.txt、overThdValue.txt这些文件。 7.1 lteDiskFullDetail.txt文件记录磁盘使用情况，当磁盘使用超过70%，则需要注意，并查找相关原因。 7.2 lteMemReport.txt文件记录各个进程使用内存情况，主要各个进程内存增加和减少的次数。如果某个进程在多个周期内只有增加，没有减少，则该进程就存在有内存泄漏的可能。 7.3 overThdValue.txt文件记录在测试过程中，哪些进程的cpu使用率超过了90%，并记录周期内超过90%次数。如果某个进程cpu使用率超过了90%，代码就有存在死循环的可能。","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]},{"title":"系统介绍","slug":"系统介绍","date":"2024-05-16T02:36:05.000Z","updated":"2024-05-16T02:38:49.005Z","comments":true,"path":"2024/05/16/系统介绍/","link":"","permalink":"http://example.com/2024/05/16/%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. 板上系统System on Board，由处理器、通信接口、存储器、模数转换器等等电路模块构成的可以实现一定功能的电路系统，这些功能模块由分立器件实现，然后通过PCB组合在一起，形成了一个板上系统。 2. 片上系统（SOC）System on Chip，片上系统 SoC 在一个芯片里就实现了存储、处理、逻辑和接口等各个功能模块，在单个硅芯片就可以实现整个系统的功能。 3. 可编程片上系统（SOPC）System On Programmable Chip，一种在可编程（FPGA）、可重新配置的芯片上实现的 SoC。 4. 全可编程片上系统（ZYNQ）它将处理器的软件可编程性与 FPGA 的硬件可编程性进行完美整合，以提供无与伦比的系统性能、灵活性与可扩展性。ZYNQ 是由两个主要部分组成的：一个由双核 ARM Cortex-A9 为核心构成的处理系统（PS，Processing System），和一个等价于一片 FPGA 的可编程逻辑（PL，Programmable Logic）部分。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"红黑树原理","slug":"红黑树原理","date":"2023-12-05T08:04:01.000Z","updated":"2023-12-05T09:30:56.700Z","comments":true,"path":"2023/12/05/红黑树原理/","link":"","permalink":"http://example.com/2023/12/05/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. 红黑树简介红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于 1978 年发明，在当时被称为平衡二叉 B 树( symmetric binary B-trees )。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。 2. 红黑树的特性节点： parent：父节点 sibling：兄弟节点 uncle：叔父节点（ parent 的兄弟节点） grand：祖父节点（ parent 的父亲节点） 特性： 节点是红色或黑色 根节点是黑色 叶子节点都是黑色（ NULL 空节点才是叶子节点） 红色节点的子节点都是黑色 红色节点的父节点都是黑色 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点 分类：红黑树与四阶 B 树具有等价特性，我们将红黑树转化为四阶 B 树后进行分类。 红黑红 黑红 红黑 黑 3. 红黑树的操作3.1 旋转操作 左旋 右旋 左旋是将某个节点 A 旋转为其右孩子节点 B 的左孩子节点 C，如果节点 C 存在，则节点 C 作为节点 A 的左孩子；右旋是将某个节点 A 旋转为其左孩子节点 B 的右孩子节点 C，如果节点 C 存在，则节点 C 作为节点 A 的有孩子。 3.2 插入操作根据红黑树的分类，插入（从叶子节点插入）分为 12 种情况，这12种均满足 1，2，3，5 特性。其中有 4 种满足特性 4，这 4 种情况插入操作不需要做任何处理，对其余 8 种需要做特殊处理。 3.2.1 RR 和 LL 情况 RR情况：父节点为祖父节点的右节点，插入节点为父节点的右节点 LL情况：父节点为祖父节点的左节点，插入节点为父节点的左节点 判定条件： uncle 不是红色节点。这里的两种情况，他们的插入节点都是没有叔父节点的，所以叔父节点也不可能是红色。 处理方法： parent 染成黑色，grand 染成红色。 grand 进行单旋操作。 LL：右旋转。 RR：左旋转。 3.2.2 LR 和 RL 情况 RL情况：父节点为祖父节点的右节点，插入节点为父节点的左节点 LR情况：父节点为祖父节点的左节点，插入节点为父节点的右节点 判定条件： uncle 不是红色节点。这两种情况的插入节点也是没有叔父节点的。 处理方法： 插入节点染成黑色，grand 染成红色。 进行双旋操作。 LR：parent 左旋转， grand 右旋转。 RL：parent 右旋转， grand 左旋转。 3.2.3 上溢的 LL 情况 上溢LL情况：父节点为祖父节点的左节点，插入节点为父节点的左节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。 判定条件： uncle 是红色节点。满足这个条件的就都是上溢的情况，上溢的修复只需要染色，不需要旋转。 处理方法： parent、uncle 染成黑色。 grand 向上合并。 将向上合并的grand染成红色，相对上一层，就当做是新添加的节点，再次来一遍插入情况的判断，进行处理。 3.2.4 上溢的 RR 情况 上溢RR情况：父节点为祖父节点的右节点，插入节点为父节点的右节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。 判定条件： uncle 是红色节点。满足这个条件的就都是上溢的情况，上溢的修复只需要染色，不需要旋转。 处理方法： parent、uncle 染成黑色。 grand 向上合并。 染成红色（其实染成红色就已经是完成了向上合并，因为祖父节点和祖父节点的父节点的连接指向并没有变），当做是新添加的节点进行处理。 3.2.5 上溢的 LR 情况 上溢LR情况：父节点为祖父节点的左节点，插入节点为父节点的右节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。 判定条件： uncle 是红色节点。满足这个条件的就都是上溢的情况，上溢的修复只需要染色，不需要旋转。 处理方法： parent、uncle 染成黑色。 grand 向上合并。 染成红色，当做是新添加的节点进行处理。 3.2.6 上溢的 RL 情况 上溢RL情况：父节点为祖父节点的右节点，插入节点为父节点的左节点。并且构成的新的B树节点已经超过了B树节点容量大小范围。 判定条件： uncle 是红色节点。满足这个条件的就都是上溢的情况，上溢的修复只需要染色，不需要旋转。 处理方法： parent、uncle 染成黑色。 grand 向上合并。 染成黑色，当做是新添加的节点进行处理。 3.2.7 插入情况总结插入一共有12种情况： 插入节点的父节点是黑色的情况有4种。这种情况仍然会维持红黑树的性质，则不需要进行额外处理。 插入节点的父节点是红色的情况有8种。这种情况不满足红黑树的性质4，需要进行额外的修复处理，这8种情况中： 叔父节点不是红色的情况有4种。 这些情况都是非上溢，需要通过重新染色和旋转来进行修复 叔父节点是红色的情况有4种。 这些情况都是上溢的，只需要通过祖父节点上溢合并和染色即可完成修复 3.3 删除操作B 树中，最后真正被删除的元素都在叶子节点中。所以在红黑树中，被删除的节点一定也在最后一层。最后一层有红色节点和黑色节点，我们就以删除节点的颜色来区分删除操作的所有情况。 如果删除的节点是红色直接删除，不用作任何调整。因为删除最后一层的红色节点，并没有影响红黑树的任何性质。 3.3.1 删除黑色节点有3种情况： 拥有 2 个红色子节点的黑色节点。 不可能被直接删除，因为会找它的子节点替代删除，因此不用考虑这种情况。 拥有 1 个红色子节点的黑色节点。 黑色叶子节点。 3.3.2 删除拥有1个红色子节点的黑色节点判定条件： 用以替代的子节点是红色节点 处理方法： 用删除节点的唯一子节点对其进行替代。 将替代节点染成黑色。 3.3.3 删除黑色叶子节点——删除节点为根节点一棵红黑树只有一个黑色根节点（也就是唯一的一个叶子节点，整个红黑树只有这一个黑色节点），可直接删除该节点，无需做其他操作。 3.3.4 删除黑色叶子节点——删除节点的兄弟节点为黑色这种情况会产生下溢（特性5）。 3.3.4.1 兄弟节点至少有1个红色子节点判定条件： 兄弟节点至少有 1 个红色子节点 处理方法： 进行旋转操作。 旋转之后的中心节点继承父节点（删除节点的父节点）的颜色。 旋转之后的左右节点染为黑色。 3.3.4.2 兄弟节点没有红色子节点判定条件： 兄弟节点没有红色子节点 处理方法： 父节点向下与兄弟节点进行合并。 将兄弟染成红色、父节点染成黑色即可修复红黑树性质。 如果父节点是黑色，直接将父节点当成被删除的节点处理，来修复父节点的下溢情况。 3.3.5 删除黑色叶子节点——删除节点的兄弟节点为红色判定条件： 兄弟节点是红色 处理方法： 兄弟节点染成 BLACK，父节点染成染成 RED，对父节点进行右旋。 于是又回到兄弟节点是黑色的情况（侄子节点变为兄弟节点），继续使用兄弟节点为黑色的方法进行修复。 4. AVL树 vs 红黑树4.1 AVL树 平衡标准比较严格：每个左右子树的高度差不超过 1。 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W 个节点，AVL 树最大树高 28）。 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整。 4.2 红黑树 平衡标准比较宽松：没有一条路径会大于其他路径的2倍。 最大高度是 2 ∗ log2(n + 1)（100W 个节点，红黑树最大树高 40）。 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整。 4.3 如何选择 搜索的次数远远大于插入和删除，选择 AVL 树；搜索、插入、删除次数几乎差不多，选择红黑树。 相对于 AVL 树来说，红黑树牺牲了部分平衡性以换取插入&#x2F;删除操作时少量的旋转操作，整体来说性能要优于 AVL 树。 红黑树的平均统计性能优于 AVL 树，实际应用中更多选择使用红黑树。 原文链接： https://blog.csdn.net/cy973071263/article/details/122543826","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"linux","slug":"linux","date":"2023-10-30T09:17:15.000Z","updated":"2025-01-22T08:50:17.833Z","comments":true,"path":"2023/10/30/linux/","link":"","permalink":"http://example.com/2023/10/30/linux/","excerpt":"","text":"0. 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172ps -elf|grep lte # 查看进程状态ps aux # 查看进程状态ps -T -p `pidof lte_agent` # 查看进程包含的线程ss -lpn |grep pidof # 查看进程套接字使用情况lspci # 查看设备上pcie设备信息的命令(pcie：一种高速串行计算机扩展总线标准)lscpu # 查看cpu相关信息shutdown -r -t 1 # 重启set -enb # 出错则停止运行ifconfig | more # 终端从头开始输出kill -9 `pidof lte_daemon` # 杀死进程# 内存free -h -w -s 3 # 每3秒打印一次内存使用情况du -sh &#123;filename&#125; # 查看文件或目录大小du -h -d 1 # 查询目录使用情况df -h # 查询磁盘分区使用情况free # 查看系统内存使用情况# 文件whereis &#123;filename&#125; # 查找二进制文件、源代码文件和man手册页find -name &#123;filename&#125; # 查找文件路径file &#123;filename&#125; # 查看文件信息true &gt; &#123;filename&#125; # 清空文件夹&gt; $filename # 将终端打印的内容重定向 $filename，&#123;$filename&#125;不存在则创建，存在清空再输入&gt;&gt; $filename # 追加scp [filename] root@192.169.46.230:&#123;path&#125; # SCP传文件tail -f [filename] |grep lte_agent # 实时输出文件内容# 网络ip addr add 10.11.1.130/24 dev eth1 # 添加IP地址ip addr del 10.11.1.130/24 dev eth1 # 删除IP地址ip route del 192.168.200.28/30 via 192.168.10.1 dev eth1 # 删除路由ip route add 192.168.200.28/30 via 192.168.10.1 dev eth1 metric 10 # 添加路由ip tuntap add eth1 mode tap # 添加虚拟网口ip tuntap add vnet1 mode tun # 添加虚拟网口，与tap有所不同，tun不带mac地址ip link add link eth0 name eth0.2 type vlan id 2 # 创建子接口ip link set eth0.1 up # 设置端口状态ip link set dev eth2 mtu 9000 # 设置端口MTU值ethtool -n eno1 # 查看端口分流规则ethtool --config-ntuple eno2 flow-type ip4 src-ip 192.168.112.118 dst-ip 192.168.112.32 action 0x0 loc 5 # 配置分流规则# 工具ssh root@10.11.1.131 # ssh连接scp &#123;srcfilename&#125; root@192.169.46.230:&#123;path&#125; # scp传文件# 环境变量env # 查看环境变量export # 设置临时环境变量unset # 删除临时环境变量# 模块modprobe vfio-pci # 挂载vfio-pci模块lsmod | grep vfio # 查看已挂载的模块rmmod vfio-pci # 卸载vfio-pci模块# 库strings lte_oam | grep VERSION # 输出进程中的字符串objdump -d --start-addres=0x428790 --stop-address=0x4287b0 lte_ncp # 将二进制转成汇编查看readelf -s libcspl_interface.so.0.0.1 | grep CSPL_Get_McbIp # 查看动态库中的接口grep -rin &quot;char&quot; ./ # 查询库中的接口# 编译gcc -E hello.c -o hello.i # 预处理gcc -S hello.c # 预处理、编译gcc -c hello.c # 预处理、编译、汇编gcc hello.c # 预处理、编译、汇编、链接gcc -E hello.c -o hello.i # 预处理gcc -S hello.i -o hello.s # 编译gcc -c hello.s -o hello.o # 汇编gcc hello.o -o hello # 链接 1. 变量 $X 的含义123456789$$ # Shell本身的PID（ProcessID） $! # Shell最后运行的后台Process的PID $? # 最后运行的命令的结束代码（返回值） $- # 使用Set命令设定的Flag一览 $* # 所有参数列表。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 $@ # 所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 $# # 添加到Shell的参数个数 $0 # Shell本身的文件名 $1～$n # 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 2. 符号 ${}、## 和 %% 的使用方法12345678910file=/dir1/dir2/dir3/my.file.txt$&#123;file#*/&#125; ：删掉第一个 / 及其左边的字符串 ：dir1/dir2/dir3/my.file.txt$&#123;file##*/&#125; ：删掉最后一个 / 及其左边的字符串 ：my.file.txt$&#123;file#*.&#125; ：删掉第一个 . 及其左边的字符串 ：file.txt$&#123;file##*.&#125; ：删掉最后一个 . 及其左边的字符串 ：txt$&#123;file%/*&#125; ：删掉最后一个 / 及其右边的字符串 ：/dir1/dir2/dir3$&#123;file%%/*&#125; ：删掉第一个 / 及其右边的字符串 ：(空值)$&#123;file%.*&#125; ：删掉最后一个 . 及其右边的字符串 ：/dir1/dir2/dir3/my.file$&#123;file%%.*&#125; ：删掉第一个 . 及其右边的字符串 ：/dir1/dir2/dir3/my 记忆的方法为：# 是 去掉左边（键盘上#在 $ 的左边）；%是去掉右边（键盘上% 在$ 的右边）；单一符号是最小匹配；两个符号是最大匹配。 3. 符号 : 的使用方法12$&#123;file:0:5&#125;：提取最左边的 5 个字节：/dir1$&#123;file:5:5&#125;：提取第 5 个字节右边的连续5个字节：/dir2 4. 符号 &#x2F; 的使用方法12$&#123;file/dir/path&#125; ：将第一个 dir 替换为 path ：/path1/dir2/dir3/my.file.txt$&#123;file//dir/path&#125; ：将全部 dir 替换为 path ：/path1/path2/path3/my.file.txt 5. 使用参数判断123456789－d ：判断制定的是否为目录－z ：判断制定的变量是否存在值－f ：判断制定的是否为文件－L : 判断制定的是否为符号链接－r ：判断制定的是否可读－s : 判断存在的对象长度是否为0－w : 判断制定的是否可写－x ：判断存在的对象是否可以执行！ ：测试条件的否定符号 6. 子shell1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；2、一个shell中的系统环境变量怎样才会被复制到子shell中（用export定义的变量）；3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）；4、不用export定义的变量只对该shell有效，对子shell是无效的。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"无线通信简介","slug":"无线通信简介","date":"2023-10-25T03:14:35.000Z","updated":"2023-10-25T05:46:00.517Z","comments":true,"path":"2023/10/25/无线通信简介/","link":"","permalink":"http://example.com/2023/10/25/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1. 无线通信基础课程介绍无线通信：蜂窝移动通信、无线局域网、短距离无线通信等课程概要：介绍无线通信的基本概念、基本原理、关键技术和系统设计方法 2. 无线通信系统与频谱无线通信是利用电磁波可以在空间中传播的特性，进行信息交换的一种通信方式，未来的无线通信可能会向量子通信，甚至引力波通信方向发展。 无线通信传输的是信息，而不是能量（与微波炉和无线充电不同），电磁波只是载体（相当于邮差）信息可以加载在电磁波的幅度上，也可以加载在频率相位和极化方式上，还可以是上诉的组合。 电磁波：电波、微波、红外线、可见光、紫外线、X射线、y射线等无线通信系统主要使用其中的微波频段，即300MHz-300GHz 毫米波通信： 一般将26.5GHz-300GHz称为毫米波频段 可用频谱宽（超过1GHz），可实现几十Gbps的传输速率 可实现射频器件小型化，有利于大规模天线阵列MassiveMIMO（天线数超过100）的实现 传播损耗快，传输距离短，器件成本高 24.75GHz-27.5GHz、37GHz-42.5GHz频段极有可能成为5G的工作频段 3. 无线通信系统发展史1820年，奥斯特发现“电能生磁”，当金属导线中有电流通过时，附近的磁针便会发生偏转。 1831年，法拉第发现“磁能生电”和“电磁感应”，导线在磁场中运动时会有电流产生的现象。 1864年，麦克斯韦建立麦克斯韦方程组，预言了电磁波的存在。 1887年，赫兹通过实验证实了电磁能量可以通过空间进行传播，并设计出了世界上第一副无线电天线。 1895年，波波夫发明无线电接收机，探测60米外发送的无线电信号。 1896年，马可尼也发明了无线电收报机。 1901年，实现了跨大西洋3000公里的无线电报。 1906年，调幅无线电广播。 1924年，车载移动电话。 1933年，调频无线电广播。 1936年，电视广播（英国BBC）。 1947年，纽约和波士顿之间建成第一条模拟微波通信线路。 1948年，香农创立了信息论，奠定了数字通信基础。 提出了熵的概念，实现了对信息的定义 提出了香农三定理（可变长无失真信源编码定理、有噪信道编码定理、保失真准则下的有失真信源编码定理） 1955年，实现全长2600公里对流层散射通信线路 1968年，模拟寻呼系统开通（1983上海） 1969年，阿波罗11号载人登月，成功地实现了月地通话和月面电视中继 1971年，美国夏威夷大学提出无线分组网络ALOHAnet 1973年，数字寻呼系统（BP机）开通（1984年广州） 蜂窝移动通信系统： 蜂窝移动通信系统中，把通信服务区分为若干个小的无线覆盖区（小区），通常表示为六角蜂窝状 每个小区设置一个基站，负责小区内移动台通信和控制 基站间通过核心网相连，并与固化系统和互联网相连 一般相邻的小区不能使用相同频率，不相邻的小区可以复用频率，提高频率使用效率 蜂窝移动通信（5代）：AMPS(1G)、GSM\\IS-95(2G)、WCDMA\\CDMA2000\\TD-SCDMA(3G)、LTE(3.9G)、LTE-A(4G)、IMT-2020(5G) 特点： 双向通信，用户可以主叫，也可以被叫 支持切换和漫游 第一代（1G）1973年，摩托罗拉公司马丁·库帕团队研制世界上第一步手机。蜂窝移动通信标准（AMPS、TACS） 特点： 模拟通信 仅能承载语音业务 语音质量较差 系统容量小，资费高 移动终端价格高，体积大，不易于携带 第二代（2G）全球移动通信系统（GSM）、窄带CDMA（IS-95） 特点： 数字通信 承载语音、短信、低速数据等多种业务 系统容量大，资费较低 移动终端价格低，体积小，易于携带 第三代（3G）2G系统支持业务比较单一，特别是无法支持宽带数据业务，3G应运而生。3G共有四个国际标准：WCDMA（中国联通）、CDMA2000（中国电信）、TD-SCDMA（中国移动）、WiMAX 特点： 扩频、码分多址 承载语音、数据、视频等多媒体业务 系统容量大，资费较低 第四代（4G）为满足快速增长的数据业务需求，3GPP提出了长期演进计划（LTE）。LTE名为演进，实际采用了OFDM、MIMO等一批革命性的技术，大幅度提升了数据传输速率，也是当前应用最广的移动通信系统。LTE包括LTE FDD和LTE TDD两大制式。 特点： 峰值速率高，下行100Mbps，上行50Mbps 网络架构扁平化，全IP组网 系统部署灵活，支持1.4MHz-20MHz多种带宽 网络时延小，业务质量有保证 第五代（5G）5G峰值数据传输速率达到10Gbps，性能达到4G的10000倍，传输延迟不超过1毫秒。 三大应用场景： 增强移动宽带（eMBB）：10Gbps峰值速率，支持3D/超高清视频 海量机器类通信（mMTC）：一百万/平方千米连接，支持大规模物联网 超高可靠低延迟通信（URLLC）：毫秒级延迟，支持无人驾驶、工业自动化、远程医疗、AR/VR等业务 2018年12月10日，工信部发放5G试验频率许可： 中国移动：2515MHz-2675MHz和4800MHz-4900MHz 中国电信：3400MHz-3500MHz 中国联通：3500MHz-3600MHz 2019年6月6日，工信部给移动、电信、联通、广电发布5G商用牌照，进入5G时代 中国：1G空白、2G跟随、3G突破、4G并跑、5G引领 4. 常用的无线通信系统无线通信系统：卫星通信、广播通信、微波通信、蜂窝移动通信、无线局域网、短距离无线通信。 卫星通信：利用人造地球卫星作为中继站转发无线电波实现两个或多个地球站之间的通信。 特点： 通信距离远，覆盖范围大 不受通信两点所处复杂地理条件的限制 安全可靠，抗毁性好（应急通信） 传输时延大，受日凌现象和太阳黑子影响大 微波通信：利用微波作为载波，来进行信息传输的一种无线通信方式 特点： 抗干扰能力好，线路噪声不累积 保密性好 组网灵活，建设周期短、成本低 对于地面的远距离通信，需要采用“中继”传输 （已逐渐被光纤通信取代，主要应用于特殊地区和特殊场景） 无线局域网（WLAN）：无线局域网是计算机网络与无线通信技术结合的产物，用无线方式将计算机连接到网络 特点： 传输速率高 使用免授权（ISM）频段 兼容性好 小型化、低成本 易于部署和维护 短距离无线通信系统：IR（红外）、RFID（射频识别）、Bluetooth（蓝牙）、Zigbee、UWB（超宽带）、Ad hoc、NFC（近场通信） 无线广播&#x2F;电视通信系统：通过无线电波向广大地区播送声音、图像、视频等节目，统称为无线广播。 特点： 成本低，覆盖范围大 单向传输 5. 无线通信面临的挑战更高的传输速率要求： 高清视频、虚拟现实&#x2F;增强现实、人工智能等技术 用户对传输速率的需求是无止境的 频谱资源稀缺： 有线通信的带宽几乎是无限的，而无线通信的带宽极为有限 目前无线通信技术可以使用的频段不超过100GHz 无线通信是开放环境，系统和用户共享频率资源 恶劣的无线电波传输环境： 高楼林立，无线电波易被遮挡，导致覆盖盲区 无线干扰源日益增加 网络建设成本激增和业务收入增长缓慢： 移动通信向着高频段和大宽带发展 发射功率一定时，频率越高，带宽越大，信号覆盖范围越小 基站数激增，增大了网络建设和维护成本","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"文件替换脚本","slug":"文件替换脚本","date":"2023-10-13T03:04:20.000Z","updated":"2024-11-18T02:57:05.832Z","comments":true,"path":"2023/10/13/文件替换脚本/","link":"","permalink":"http://example.com/2023/10/13/%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/bin/bashset -eAPPNAME=LTEBAKID=&quot;bkforIPRouteTest&quot;CURDIR=$(pwd)WORKDIR=$( cd &quot;$(dirname $0)&quot; pwd)SRCFILEDIR=$WORKDIR/source# /LTE/user/Area0/bin/ lte_agent# /LTE/user/Area0/cfg/ btscfg.db# /LTE/user/Area0/cfg/ btsmincfg.json# /LTE/user/Area0/cfg/ eNodeBCfg.json# /LTE/user/Area0/resource/mometa/ IPROUTE.jsonLIST=( &quot;lte_agent&quot; \\ &quot;lte_trm.sh&quot; \\ &quot;iproute.py&quot; \\ &quot;devip.py&quot; \\ # &quot;IPROUTE.json&quot; \\ )SRCDIR=(&quot;$SRCFILEDIR&quot; \\ &quot;$SRCFILEDIR&quot; \\ &quot;$SRCFILEDIR&quot; \\ &quot;$SRCFILEDIR&quot; \\ # &quot;$SRCFILEDIR&quot; \\ )DSTDIR=(&quot;/LTE/user/Area0/bin&quot; \\ &quot;/LTE/user/Area0/bin&quot; \\ &quot;/LTE/user/Area0/resource/mocons/rules/enodeb/trp&quot; \\ &quot;/LTE/user/Area0/resource/mocons/rules/enodeb/trp&quot; \\ # &quot;/LTE/user/Area0/resource/mometa&quot; \\ )# param1: LIST# param2: SRCDIR# param3: DSTDIRupdate_f()&#123; LIST=($1) SRCDIR=($2) DSTDIR=($3) for ((i = 0; i &lt; $&#123;#LIST[@]&#125;; i++)); do filepath=$&#123;DSTDIR[i]&#125;/$&#123;LIST[i]&#125; backpath=$filepath.$BAKID if [ ! -f $backpath ]; then cp -f $filepath $backpath || true fi cp -f $&#123;SRCDIR[i]&#125;/$&#123;LIST[i]&#125; $filepath done&#125;# param1: LIST# param2: DSTDIRrestore_f()&#123; LIST=($1) DSTDIR=($2) for ((i = 0; i &lt; $&#123;#LIST[@]&#125;; i++)); do filepath=$&#123;DSTDIR[i]&#125;/$&#123;LIST[i]&#125; backpath=$filepath.$BAKID mv -f $backpath $filepath || true done&#125;update() &#123; cd $WORKDIR update_f &quot;$&#123;LIST[*]&#125;&quot; &quot;$&#123;SRCDIR[*]&#125;&quot; &quot;$&#123;DSTDIR[*]&#125;&quot; echo &quot;update apply ok&quot;&#125;restore() &#123; cd $WORKDIR restore_f &quot;$&#123;LIST[*]&#125;&quot; &quot;$&#123;DSTDIR[*]&#125;&quot; echo &quot;restore ok&quot;&#125;help() &#123; echo &quot;&quot; echo &quot; $&#123;0&#125; &lt;update|restore&gt;&quot; echo &quot; ------------------------------------------------------------ &quot; echo &quot; $&#123;0&#125; update: 使用source目录下的文件，应用补丁到$&#123;APPNAME&#125;&quot; echo &quot; $&#123;0&#125; restore: 使用备份文件恢复$&#123;APPNAME&#125;到补丁前状态&quot; echo &quot; $&#123;0&#125; help: 显示本帮助信息&quot; echo &quot; ------------------------------------------------------------ &quot; echo &quot;&quot;&#125;if [ $# -ge 1 ]; then if [ &quot;$1&quot; == &quot;update&quot; ]; then update elif [ &quot;$1&quot; == &quot;restore&quot; ]; then restore else help fi exit 0fihelp","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"VPP常用命令","slug":"VPP常用命令","date":"2023-09-16T08:20:42.000Z","updated":"2024-11-18T06:08:21.713Z","comments":true,"path":"2023/09/16/VPP常用命令/","link":"","permalink":"http://example.com/2023/09/16/VPP%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"VPP常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 创建/删除主机接口G0create host-interface name G0delete host-interface name G0 # 设置端口状态up/downset int state G0 upset int state G0 down# 设置端口MTU值set interface mtu 9000 eth1# 添加/删除VLAN子接口create sub-interfaces G1 100delete sub-interfaces G1.100# 添加/删除IP地址，VLAN不为1set int ip address G0 192.168.59.134/24set int ip address del G0 192.168.59.134/24set int ip address G0.2 192.168.59.134/24set int ip address del G0.2 192.168.59.134/24# 添加/删除路由ip route add 0.0.0.0/0 via 0.0.0.0ip route del 0.0.0.0/0 via 0.0.0.0# 添加/删除MAC地址set int mac address G0 00:00:00:00:00:00set int mac address del G0 00:00:00:00:00:00# VPP抓包## 接口抓包pcap trace rx tx drop max 100000 file vpp_any.pcap max-bytes-per-pkt 1000pcap trace rx tx drop max [number] intfc [eth] file [filename.pcap] max-bytes-per-pkt [number]pcap trace rx tx max [number]pcap trace rx tx statuspcap trace off##节点抓包pcap dispatch trace on max 100000 file vpp-dispatch-trace.pcappcap dispatch trace off# 查看端口、路由、ARP表信息show intshow int addrshow hardware-interfacesshow ip fibshow ip arpshow ip neighborshow ip6 neighborshow dpdk buffershow dpdk intshow versionshow pluginshow threadsshow memory# 添加/删除table表ip table add &lt;table-id&gt;ip table del &lt;table-id&gt;# 添加/删除桥create bridge-domain 100delete bridge-domain 100# 将VLAN放在桥下set int l2 bridge G1.100 100# 删除桥，再删除桥接域set int l3 G0create bridge-domain 100 del# memif添加/删除create interface memif id 0 mastercreate interface memif id 0 slaveset int state memif0/0 upset int ip address host-vpp 10.0.0.2/24delete interface memif memif0/0delete memif socket id 0","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"VPP成长之路","slug":"VPP成长之路","date":"2023-09-16T06:35:53.000Z","updated":"2024-11-18T06:08:29.504Z","comments":true,"path":"2023/09/16/VPP成长之路/","link":"","permalink":"http://example.com/2023/09/16/VPP%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"1. VPP安装 安装Ubuntu：版本：Ubuntu 20.04.4 保证ubuntu可上网（虚拟机网络配置） 更新apt，sudo apt-get update -y 安装git ，sudo apt install git 安装vim， sudo apt install vim 下载vpp源码 ：git clone http://gerrit.fd.io/r/vpp 很慢很慢（git到的路径为当前路径） 安装一些必要的软件：sudo apt install make ， sudo apt install make-guile ，sudo apt install openssh-server 下载关系依赖：make install-dep ， make dpdk-install-dev （下载时没成功，不影响），make install-ext-deps #时间较长 编译：make build （也可执行：.&#x2F;extras&#x2F;vagrant&#x2F;build.sh）、make pkg-deb 自动配置大页：dpkg -i build-root&#x2F;*.deb 安装DPDK12345sudo apt install mesonsudo apt install -y python3-pyelftools python-pyelftoolsgit clone https://gitee.com/yaozuluo/dpdk.git cd dpdkmeson -Dexamples=all build 启动VPP，暂且不用配置其他文件，只是看到VPP运行123systemctl enable vppsystemctl start vppsystemctl status vpp.service 测试是否安装成功：sudo vppctl 2. 实例2.1 运行多个VPP1234567sudo rm -rf /usr/lib/x86_64-linux-gnu/vpp_plugins/dpdk_plugin.so # 删除dpdk插件sudo vpp unix &#123;cli-listen /run/vpp/cli-vpp1.sock&#125; api-segment &#123; prefix vpp1 &#125; # 创建VPP # api-segment &#123;前缀 vpp1&#125; 告诉 vpp 如何以不同于默认值的方式命名 vpp 实例的 /dev/shm/ 中的文件。 # Unix &#123;cli-listen /run/vpp/cli-VPP1.sock&#125;“告诉VPP在由VPPCTL寻址时使用非默认套接字文件。sudo vpp unix &#123;nodaemon cli-listen /run/vpp/cli-vpp1.sock&#125; api-segment &#123; prefix vpp1 &#125; # 激活 nodaemon 选项以更好地了解正在发生的事情sudo vppctl -s /run/vpp/cli-vpp1.sock # 运行VPP 2.2 创建虚拟网口（主机与VPP之间）让VPP简单地跑通，使用命令创建网口，开启主机到VPP的通道，一般采用veth技术。 创建虚拟网口连接到vpp内部建立通讯： 123456ip link add vhost type veth peer name vpp # 创建成对的虚拟网口vhost及vppip link set vhost upip link set vpp up # 开启它俩ip addr add 10.0.0.1/24 dev vhost # 为主机侧指定ip地址sudo ip link del dev vpphost # 删除veth接口 VPP指令: 123456create host-interface name vpp # 创建主机接口，用vppset int state host-vpp up # host-vpp是vpp生成的，可以用show int确认名称set int ip address host-vpp 10.0.0.2/24 # 指定ip地址show int # 能看到接收发送的一些数据统计信息delete host-interface name vpp # 删除主机接口vpp 在主机用ping 10.0.0.2应该能通了，并且vpp里面通过show int能看到统计数据在变化；主机通过tcpdump应该能抓到包。VPP中使用trace跟踪： 123456trace add af-packet-input 10 trace add memif-input 10 # 添加跟踪show trace # 查看跟踪信息clear trace # 清除跟踪缓存区show ip neighbors # 检查ARP表show ip fib # 查看路由表 关闭vpp进程，删除虚拟接口 123ps -ef | grep vpp | awk &#x27;&#123;print $2&#125;&#x27;| xargs sudo killsudo ip link del dev vpp1hostsudo ip link del dev vpp1vpp2 2.3 连接两个VPP实例MEMIF 是一种性能非常高的直接内存接口类型，可以在 VPP 实例之间用于形成拓扑。它使用控制通道的文件套接字来设置该共享内存。 在两个 vpp 实例之间创建内存接口：在vpp1和vpp2上各创建一个 memif 接口： 1234create interface memif id 0 mastercreate interface memif id 0 slaveset int state memif0/0 upset int ip address host-vpp 10.0.0.2/24 2.4 路由 将路由添加到 Linux 主机路由表 将路由添加到 vpp 路由表 设置路由： 1ip route add 10.10.1.0/24 via 10.10.2.1 # via下一跳IP地址 2.5 切换 将接口与桥接域关联 创建环回接口 为桥接域创建 BVI（网桥虚拟接口） 检查桥接域 123456789101112131415161718192021# 显示桥show bridge-domain [bridge-domain-id [detail|int|arp]]. # 命令格式show bridge-domain # 显示所有桥接域show bridge-domain 1 detail # 显示单个桥接域# 设置Int L2桥接器set interface l2 bridge &lt;interface&gt; &lt;bridge-domain-id&gt; [bvi] [shg]. # 命令格式set int l2 bridge host-vpp1out 1 # 设置host-vpp1out到桥接域1set int l2 bridge loop0 1 bvi # loop0设置为桥接虚拟接口（bvi）到桥接域 1# 创建环路接口create loopback interfaceset int state loop0 upset int ip address loop0 10.10.1.2/24 # 显示L2FIB详细show l2fib [verbose | bd_id &lt;nn&gt; | bd_index &lt;nn&gt; | raw]. # 命令格式show l2fib verbose# ping测试指定源端口ping 10.0.0.1 source loop0 2.6 源NAT 滥用网络命名空间以获取乐趣和利润 配置抢断地址 配置 snat 内部和外部接口 1234567891011# 创建一个inside网络空间sudo ip netns add inside# 将接口 vpp1inside 移动到“inside”命名空间中sudo ip link set dev vpp1insidehost up netns inside# 将 IP 地址分配给 vpp1insidehostsudo ip netns exec inside ip addr add 10.10.2.1/24 dev vpp1insidehost# 在网络内创建路由sudo ip netns exec inside ip route add 10.10.1.0/24 via 10.10.2.2 3. 源码3.1 源码目录 目录名称 描述 build-data 构建元数据 build-root 构建输出目录 doxygen 文档生成器配置 dpdk DPDK补丁与构建基础设施 extras&#x2F;libmemif memif的客户端库 src&#x2F;examples VPP示例代码 src&#x2F;svm VPP的捆绑插件目录 src&#x2F;tests 共享虚拟内存分配库（Shared virtual memory） src&#x2F;vat 独立测试（不属于测试套件） src&#x2F;vlib VPP应用程序库 src&#x2F;vlibapi VPP API库 src&#x2F;vlibsocket VPP Socket I&#x2F;O src&#x2F;vnet VPP网络 src&#x2F;vpp VPP应用程序 src&#x2F;vpp-api VPP应用程序API绑定 src&#x2F;vppinfra VPP核心库 src&#x2F;vpp&#x2F;api 尚未重新放置在新地方的API绑定 test 单元测试和Python测试工具 3.2 源码分类vpp数据平面分为四个不同的层： 基础架构层：包括vppinfra，vlib，svm和二进制api库。源码：&#x2F;src&#x2F;{vppinfra, vlib, svm, vlibapi, vlibmemory} 通用网络协议栈层：vnet。源码：&#x2F;src&#x2F;vnet 应用程序shell：vpp。源码：&#x2F;src&#x2F;vpp 日益丰富的数据平面插件。源码：&#x2F;src&#x2F;plugins 3.2.1 Vppinfra：Vppinfra是一个基本的c-library服务集合，可以构建直接在裸机上运行的独立程序。它提供高性能动态数组，hash表，位图，高精度实时时钟支持，精细的日志记录和数据结构序列化。 Vectors Vppinfra向量是无处不在的动态调整大小的数组，具有用户定义的“头”。许多vpppinfra数据结构（例如hash，堆，池）是具有各种不同头的向量。 12345678内存布局如下所示： User header (optional, uword aligned) Alignment padding (if needed) Vector length in elementsUser&#x27;s pointer -&gt; Vector element 0 Vector element 1 ... Vector element N-1 如上所示，向量API处理指向向量第0个元素的指针。 如果指为空针则说明向量的有效长度为0。 为了避免内存分配器的分配失败，通常在保留内存分配的同时将向量的长度重置为零。通过vec_reset_length（v）宏将向量长度字段设置为零。 通常情况下不存在用户标头。用户头允许在vppinfra向量上构建其他数据结构。用户可以通过vec * _aligned宏指定数据元素的对齐方式。 向量元素可以是任何C语言数据结构类型，例如 （int，double，struct ）。许多宏都用_a类型的变体支持向量数据的对齐，而_h类型的变体支持非零长度向量头。_ha类型的变体支持以上两者。 头或对齐相关宏类型的变体使用不一致将导致延迟以及各种失败问题。 Bitmaps Vppinfra位图是动态的，使用vppinfra向量API来构建。 Pools Vppinfra池结合了Vectors和Bitmaps，可以快速分配和释放具有独立生命周期的固定大小的数据结构。池非常适合给每个会话分配结构。 Hashes Vppinfra提供了几种不通类型的哈希。 在涉及数据包分类&#x2F;会话查找相关的数据平面问题是通常使用&#x2F;src&#x2F;vppinfra&#x2F;bihash_templat.[ch] 有界索引可扩展哈希值。Bihashes是线程安全的。，不需要读取锁。只需要一个简单的自旋锁确保在同一时刻一次只有一个线程写入一个entry。 在涉及需要字符串精确匹配的控制平面代码中通常使用&#x2F;src&#x2F;vppinfra&#x2F;hash.[ch]中的原始vppinfra哈希。 Format Vppinfra中的Format大致相当于c语言中的printf。 Format的第一个参数是（u8 *）向量，它附加当前格式化操作的结果。 12345调用示例：u8 * result;result = format (0, &quot;junk = %d, &quot;, junk);result = format (result, &quot;more junk = %d\\n&quot;, more_junk); NULL指针是完全正确的0长度向量。格式返回（u8 *）向量，而不是C字符串。如果要打印（u8 *）向量，需要使用“％v”格式字符串。 如果想要一个（u8 *）向量同时也是一个正确的C字符串，可以使用以下任一方案： 12345678u8 * format_junk (u8 * s, va_list *va)&#123; junk = va_arg (va, u32); s = format (s, &quot;%s&quot;, junk); return s;&#125;result = format (0, &quot;junk = %U, format_junk, &quot;This is some junk&quot;); Unformat Vppinfra的unformat与scanf有点类似，但是更加的通用。 从C-string或（u8 *）向量初始化unformat_input_t，然后通过unformat（）进行解析，如下所示： 12345unformat_input_t input;unformat_init_string (&amp;input, &quot;&lt;some-C-string&gt;&quot;);/* or */unformat_init_vector (&amp;input, &lt;u8-vector&gt;); 然后循环解析各个元素： 12345678910while (unformat_check_input (&amp;input) != UNFORMAT_END_OF_INPUT) &#123; if (unformat (&amp;input, &quot;value1 %d&quot;, &amp;value1)) ;/* unformat sets value1 */ else if (unformat (&amp;input, &quot;value2 %d&quot;, &amp;value2) ;/* unformat sets value2 */ else return clib_error_return (0, &quot;unknown input &#x27;%U&#x27;&quot;, format_unformat_error, input);&#125; Vppinfra errors and warnings vpp数据平面中的许多函数都具有clib_error_t *类型的返回值。如果返回NULL则clib_error_t *表示“正确，没有错误”。 Clib_warning（）是一种添加调试的便捷方式；clib警告预置的功能：自动添加行信息以明确定位消息源。 Serialization Vppinfra序列化功能支持允许程序员轻松地序列化和反序列化复杂的数据结构。底层的原始序列化&#x2F;反序列化函数使用网络字节序，因此在小端主机上序列化并在大端主机上反序列化不会存在结构问题。 Event-logger, graphical event log viewer vppinfra事件记录器提供轻量级的精确时间戳（低于100ns）事件记录服务。代码：&#x2F;src&#x2F;vppinfra&#x2F;{elog.c, elog.h} 序列化支持可以轻松保存并合并一组事件日志。 典型的事件定义和日志记录调用如下所示： 1234567ELOG_TYPE_DECLARE (e) = &#123; .format = &quot;get_or_create: %s&quot;, .format_args = &quot;t4&quot;, .n_enum_strings = 2, .enum_strings = &#123; &quot;old&quot;, &quot;new&quot;, &#125;,&#125;; 如下所示：“.format”字段可能包含以下一个或多个实例： 12345678910i1 - 8-bit unsigned integeri2 - 16-bit unsigned integeri4 - 32-bit unsigned integeri8 - 64-bit unsigned integerf4 - floatf8 - doubles - 以NULL结尾的字符串sN - N字节字符数组t1,2,4 - 每一个事件枚举IDT4 - 事件日志字符串表的偏移量 vpp引擎有几个事件日志的调试CLI： 12345vpp# event-logger clearvpp# event-logger save &lt;filename&gt; # for security, writes into /tmp/&lt;filename&gt;. # &lt;filename&gt; must not contain &#x27;.&#x27; or &#x27;/&#x27; charactersvpp# show event-logger [all] [&lt;nnn&gt;] # display the event log # by default, the last 250 entries 事件日志默认为128K条entry。 命令行参数“vlib {elog-events }”配置事件日志的entry大小。 3.2.2 VLIB：Vlib提供向量处理支持，包括图形节点调度，可靠多播支持，超轻量级协作多任务线程，CLI，.DLL插件支持，物理内存和Linux epoll支持。 Node Graph Initialization vlib数据包处理应用程序总是定义一组图节点来处理数据包。通过VLIB_REGISTER_NODE宏来构造vlib_node_registration_t数据结构。在运行时，框架将这样的注册集处理成有向图。在运行时向图添加节点很容易，该框架不支持删除节点。 1234567vlib_node_registration_t的类型成员函数如下：VLIB_NODE_TYPE_PRE_INPUT：在所有其他节点类型之前运行VLIB_NODE_TYPE_INPUT：在pre_input节点之后尽可能的经常运行VLIB_NODE_TYPE_INTERNAL：仅当通过添加待处理帧进行处理而明确地使其可运行时VLIB_NODE_TYPE_PROCESS：只有在明确地设置为runnable时。“进程”节点实际上是协作的多任务线程。 他们必须在相当短的时间后明确暂停。 要准确理解图节点调度程序，请阅读：&#x2F;src&#x2F;vlib&#x2F;main.c:vlib_main_loop Graph node dispatcher Vlib_main_loop（）调度图节点。 4.B站","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"虚拟机网络配置","slug":"虚拟机网络配置","date":"2023-09-16T05:40:07.000Z","updated":"2024-11-18T02:56:52.993Z","comments":true,"path":"2023/09/16/虚拟机网络配置/","link":"","permalink":"http://example.com/2023/09/16/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"NAT 模式 如果主机可以上网，虚拟机可以上网 虚拟机之间不能ping通 虚拟机可以ping通主机（此时ping虚拟机的网关，即是ping主机） 主机不能ping通虚拟机 桥接模式 如果主机可以上网，虚拟机可以上网 虚拟机之间可以ping通 虚拟机可以ping通主机 主机可以ping通虚拟机 以上各点基于一个前提：主机可以上网 如果主机不可以上网，所有1-4特点均无 Host-Only Adapter 模式 虚拟机不可以上网 虚拟机之间可以ping通 虚拟机可以ping通主机（注意虚拟机与主机通信是通过主机的名为VirtualBox Host-Only Network的网卡，因此ip是该网卡ip 192.168.56.1，而不是你现在正在上网所用的ip） 主机可以ping通虚拟机","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"云外安装项目程序","slug":"云外安装项目程序","date":"2023-09-08T07:40:37.000Z","updated":"2024-05-29T05:35:54.392Z","comments":true,"path":"2023/09/08/云外安装项目程序/","link":"","permalink":"http://example.com/2023/09/08/%E4%BA%91%E5%A4%96%E5%AE%89%E8%A3%85%E9%A1%B9%E7%9B%AE%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ftp://192.168.154.201/BWT-3800_eNB_V3.5_X86_64_B2/eNB_build/20230904_0550_470/pkg/testtest@2020cd var/volatiletar -zxvf OBBU_V3.5.01.050.tar.gzchmod +x install./install.sh OBBU_V3.5.01.050.tar APP # 本地调试安装，通过tar包安装，带APP参数，不装底软ip addr add 10.11.1.130/24 dev enp0s10 # 添加IP 删除IP：ip addr del 10.11.1.130/24 dev enp0s10systemctl stop firewalld # 关闭防火墙cd ./user/Area0/bin # 切换工作路径startLTE # 启动程序。第一次可能失败，失败的话直接运行程序lte_check_tool p # 查看进程是否启动成功stopLTE # 关闭程序vim /LTE/user/Area0/bin/lte_trm.sh # 本地运行的网络接口跟lte_trm.sh中定义的接口名称不同，1.130地址 # 自动配置过程会导致手动配置的130IP被去除，将下面的配置过程注释掉 # trm_configure_cu_130_ip_for_socket_scheme_for_380x # trm_clear_380x_cu_130_ip_for_vpp_schemevim /LTE/user/Area0/cfg/startup.conf # 配置VPP的CPU使用，以免启动失败 # main-core 5 -&gt; main-core 0 # corelist-workers 6-7: -&gt; corelist-workers 1: # dev 0000:04:00.0 -&gt; 0000:00:09.0vim /LTE/user/Area0/cfg/cspl_config.xml # 禁止协议栈重拉已挂进程 # &lt;restartMode&gt;0&lt;/restartMode&gt; -&gt; &lt;restartMode&gt;3&lt;/restartMode&gt;vim /LTE/user/Area0/bin/lte_trm.sh # 修改VPP端口名称 ETH_NAME_VPP # 修改内核态端口名称 eno1,eno2,eno3vim /LTE/user/Area1/trp/trm.cfg # 修改内核态端口名称vim /LTE/user/Area3/Swver2/Area0/bin/lte_startup.sh # 添加 LD_LIBRARY_PATH # TARGETDIR=/LTE/user/Area3/Swver2/Area0 # export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TARGETDIR/lib/ipsec:$TARGETDIR/lib/ipsec/plugins:$TARGETDIR/lib/vpp_api_test_plugins./platform/oam/core/clock_mgmt/src/clock_mgmt.c # dev_cfg_ptp_params() # //调用统一接口进行配置 # if (0 == (ret = bsp ptp cfg(&amp;ptp cfg params))) # &#123; # CSPL Log(DEV MODULE ID,CSPL LOG NOTICE,&quot;bsp_ptp cfg ok!\\n&quot;); # &#125; # else # &#123; # CSPL Log(DEV MODULE ID,CSPL LOG ERROR,&quot;bsp_ptp mode cfg failed, ret is %x !\\n&quot;, ret); # &#125;","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]},{"title":"网络管理工具","slug":"网络管理工具","date":"2023-09-07T08:54:14.000Z","updated":"2025-03-27T07:57:27.893Z","comments":true,"path":"2023/09/07/网络管理工具/","link":"","permalink":"http://example.com/2023/09/07/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"","text":"网络管理常用命令arp、arping、ip、route、netstat 1--help 1. arp1234567891011121314151617-a # 主机 ：显示 arp 缓冲区的所有条目；-H # 地址类型 ：指定 arp 指令使用的地址类型；-d # 主机 ：从 arp 缓冲区中删除指定主机的 arp 条目；-D # 使用指定接口的硬件地址；-e # 以 Linux 的显示风格显示 arp 缓冲区中的条目；-i # 接口 ：指定要操作 arp 缓冲区的网络接口；-s # 主机 MAC 地址 ：设置指定的主机的 IP 地址与 MAC 地址的静态映射；-n # 以数字方式显示 arp 缓冲区中的条目；-v # 显示详细的 arp 缓冲区条目，包括缓冲区条目的统计信息；-f # 文件 ：设置主机的 IP 地址与 MAC 地址的静态映射。arp -v # 显示 arp 缓冲区内容arp -s [IP] [MAC-ADDRESS] # 添加静态 arp 条目arp -d [IP] # 删除 arp 缓存条目sudo ip neigh flush all # 清空 arp 缓存表arp -n # 查看当前 arp 表arp -a # 刷新 arp 缓存表（删除所有 arp 条目并重新查询） 2. arping语法：arping [-fqbDU] [-c count] [-w timeout] [-I device] [-s source] destination 1234567891011-f # 收到第一个reply就立即退出-q # 安静模式，什么都不输出-b # 只发送广播，不发送单播-D # 地址冲突检测-U # 主动更新邻居的arp缓存(Unsolicited ARP mode)-c count # 发送多少个arp请求包后退出-w timeout # 等待reply的超时时间-I device # 使用哪个接口发送请求包。发送arp请求包接口的MAC地址将缓存在目标主机上-s source # 指定arp请求报文中源地址，若发送的接口和源地址不同，则目标主机将缓存该地址和接口的MAC地址， # 而非该源地址所在接口的MAC地址destination # 向谁发送arp请求报文，即要获取该IP或主机名的MAC地址 请求解析192.168.100.70主机的MAC地址 sh arping -f 192.168.100.70 这将会发送广播报文，直到收到192.168.100.70的回复才退出。 同时，192.168.100.70也会缓存本机的IP和MAC对应条目，由于此处没有指定请求报文的发送接口和源地址，所以发送报文时是根据路由表来选择接口和对应该接口地址的。 指定发送一个请求报文给192.168.100.70就退出，发送报文的接口为eth1，并指定请求报文中的源地址为本机eth0接口上的地址192.168.100.54 sharping -c 1 -I eth1 -s 192.168.100.54 192.168.100.70 发送这样的arp请求包，将会使得目标主机192.168.100.70缓存本机的arp条目为”192.168.100.54 MAC_eth1”，但实际上，192.168.100.54所在接口的MAC地址为MAC_eth0。 探测对方主机是否存活 sharping -c 4 -I eth0 192.168.100.2 3.ipip 命令是 Linux 加强版的的网络配置工具，用于代替 ifconfig 命令。语法： ip [ OPTIONS ] OBJECT { COMMAND | help } OPTIONS 为常用选项，值可以是以下几种： 1234567891011OPTIONS=&#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] &#123; inet | inet6 | ipx | dnet | link &#125; | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] &#125;-V # 显示命令的版本信息；-s # 输出更详细的信息；-f # 强制使用指定的协议族；-4 # 指定使用的网络层协议是IPv4协议；-6 # 指定使用的网络层协议是IPv6协议；-0 # 输出信息每条记录输出一行，即使内容较多也不换行显示；-r # 显示主机时，不使用IP地址，而使用主机的域名。 OBJECT 为常用对象，值可以是以下几种： 12345678OBJECT=&#123; link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token &#125;link # 网络设备address # 设备上的协议（IP或IPv6）地址addrlabel # 协议地址选择的标签配置route # 路由表条目rule # 路由策略数据库中的规则 实例： 12345678910111213141516171819202122232425ip link show # 显示网络接口信息ip link set eth0 up # 开启网卡ip link set eth0 down # 关闭网卡ip link set eth0 promisc on # 开启网卡的混合模式ip link set eth0 promisc offi # 关闭网卡的混个模式ip link set eth0 txqueuelen 1200 # 设置网卡队列长度ip link set eth0 mtu 1400 # 设置网卡最大传输单元ip addr show # 显示网卡IP信息ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址ip route show # 显示系统路由ip route add default via 192.168.1.254 # 设置系统默认路由ip route list # 查看路由信息ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254ip route del 192.168.4.0/24 # 删除192.168.4.0网段的网关ip route del default # 删除默认路由ip route delete 192.168.1.0/24 dev eth0 # 删除路由ip link list # 显示网络设备的运行状态ip route list # 显示核心路由表ip neigh list # 显示邻居表ip link | grep -E &#x27;^[0-9]&#x27; | awk -F: &#x27;&#123;print $2&#125;&#x27; # 获取主机所有网络接口 4. routeroute命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。语法： route (选项) (参数) 选项： 1234567-A # 设置地址类型；-C # 打印将Linux核心的路由缓存；-v # 详细信息模式；-n # 直接显示数字形式的IP地址；-e # netstat格式显示路由表；-net # 到一个网络的路由表；-host # 到一个主机的路由表。 参数： 1234567add # 增加指定的路由记录；del # 删除指定的路由记录；target # 目的网络或目的主机；gw # 设置默认网关；mss # 设置TCP的最大区块长度（MSS），单位MB；window # 指定通过路由表的TCP连接的TCP窗口大小；dev # 路由记录所表示的网络接口。 路由表介绍： 1234567891011121314[root@localhost ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault gateway 0.0.0.0 UG 100 0 0 ens33link-local 0.0.0.0 255.255.0.0 U 1003 0 0 br0192.168.186.0 0.0.0.0 255.255.255.0 U 100 0 0 ens33Destination # 目的地址；Gateway # 指定的网关；Genmask # 掩码；Flags # 网络节点的状态；U(used):使用中，G(gateway)：网关 ,H(host):是一个主机而非网络。Metric # 下一跳；Ref # 被引用的次数；Iface # 网卡。 示例： 12345route add -net 10.0.0.0/24 dev ens33 # 添加一个网络route add -net 10.1.0.0/24 dev ens33 gw 192.168.186.2 # 指定网关添加网络route add -host 10.1.1.1 dev ens33 # 添加一个主机IProute del -net 10.0.0.0/24 # 删除网络route del -host 10.1.1.1 # 删除主机 5. netstatnetstat 命令用于显示网络状态。语法： netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip] 参数说明： 1234567891011121314151617181920212223-a或--all # 显示所有连线中的Socket。-A&lt;网络类型&gt;或--&lt;网络类型&gt; # 列出该网络类型连线中的相关地址。-c或--continuous # 持续列出网络状态。-C或--cache # 显示路由器配置的快取信息。-e或--extend # 显示网络其他相关信息。-F或--fib # 显示路由缓存。-g或--groups # 显示多重广播功能群组组员名单。-i或--interfaces # 显示网络界面信息表单。-l或--listening # 显示监控中的服务器的Socket。-M或--masquerade # 显示伪装的网络连线。-n或--numeric # 直接使用IP地址，而不通过域名服务器。-N或--netlink或--symbolic # 显示网络硬件外围设备的符号连接名称。-o或--timers # 显示计时器。-p或--programs # 显示正在使用Socket的程序识别码和程序名称。-r或--route # 显示Routing Table。-s或--statistics # 显示网络工作信息统计表。-t或--tcp # 显示TCP传输协议的连线状况。-u或--udp # 显示UDP传输协议的连线状况。-v或--verbose # 显示指令执行过程。-V或--version # 显示版本信息。-w或--raw # 显示RAW传输协议的连线状况。-x或--unix # 此参数的效果和指定&quot;-A unix&quot;参数相同。--ip或--inet # 此参数的效果和指定&quot;-A inet&quot;参数相同。","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"数据通信与网络技术","slug":"数据通信与网络技术","date":"2023-08-30T06:10:42.000Z","updated":"2023-09-07T09:38:40.357Z","comments":true,"path":"2023/08/30/数据通信与网络技术/","link":"","permalink":"http://example.com/2023/08/30/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/","excerpt":"","text":"1. 知识点记录网络： 将距离较近的计算机通过网线连接到交换机就可以形成一个网络互联网： 多个网络通过路由器互连即可形成互联网Internet： 最大的互联网 网络拓扑类型： 星形、总线型、环形、树形、全网状、部分网状、组合型企业通常采用： 树形、组合型 组网设备： 同轴电缆、集线器、交换机、路由器、防火墙、无线设备（无线接入点AP、无线控制器AC） 交换机： MAC地址； 根据MAC地址实现转发，可以实现单播、组播、广播； 内部有MAC地址表； 其工作在OSI第二层数据链路层。 路由器： IP地址； 根据IP地址进行路由，隔绝广播域； 内部有IP路由表； 其工作在OSI第三层网络层。 路由： 直接路由、动态路由、静态路由三层网络： 接入层、汇聚层、核心层二层转发、三层路由 2. TCP&#x2F;IPv4协议栈应用层协议： HTTP（HyperText Transfer Protocol）：超文本传输协议，用于访问Web服务。 HTTPS（HyperText Transfer Protocol over Secure Socket Layer）：安全的超文本传输协议，能够将HTTP通信进行加密传输。 SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件。 POP3（Post Office Protocol 3）：邮局协议版本3，用于接收电子邮件。 DNS（Domain Name System）：域名解析协议，用于域名解析。 FTP（File Transfer Protocol）：文件传输协议，用于在Internet上传和下载文件。 Telnet：远程登录协议，用于远程配置网络设备，Linux系统和Windows系统。 DHCP（Dynamic Host Configuration Protocol）：动态主机配置协议，用于计算机或其他网络设备自动配置IP地址、子网掩码、网关和DNS等。 传输层协议： TCP、UDP 网络层协议： IP、ICMP、ARP 网络接口层协议： CSMA&#x2F;CD、PPP、HDLC、帧中继、X.25； 三个基本功能：封装成帧、透明传输和差错检查。 3. NAT(网络地址转换)在IP地址空间里，A、B、C3类地址中各保留一部分地址作为私网地址。私网地址不能出现在公网上，公网中的路由器没有到私网的路由。在路由上做NAT需要修改数据包的网络层和传输层。保留的私网地址： A类地址：10.0.0.0~10.255.255.255 B类地址：172.16.0.0~172.31.255.255 C类地址：192.168.0.0~192.168.255.255 NAT的5种类型： 静态NAT、动态NAT、NAPT、Easy IP和NAT Server1. 静态NAT： 私网地址与公网地址一一绑定对应，不节省公网地址； 外部网络可以访问内部网络。 2. 动态NAT： 提供地址池，私网地址与公网地址也是一对一，但不绑定，一般用于内网主机多于可用公网IP地址的情况。 因为是一对一的关系，所以无法提高公网地址的利用率； 外部网络无法主动访问内网主机。 3. NAPT： 提供地址池，不仅转换IP地址，还会对端口号进行转换，因此可以实现一个IP地址不同端口号来实现，公网地址的一对多。 外部网络无法主动访问内网主机。 4. Easy IP： 基本与NATP相同，但没有地址池，使用接口地址作为NAT转换的公网地址，其只会用到一个IP地址。 5. NAT Server： 应用于私网网络中的服务器需要对公网提供服务的情况，指定【公网地址：端口】与【私网地址：端口】一一对应。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"程序","slug":"程序","date":"2023-08-29T11:53:40.000Z","updated":"2023-12-12T01:42:37.370Z","comments":true,"path":"2023/08/29/程序/","link":"","permalink":"http://example.com/2023/08/29/%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"消息结构：1234567891011121332字节的CSPL_HEAD + PayloadCSPL_HEAD: Magic(4)+TRANS_ID(4)+SRC_ID(4)+DST_ID(4)+API_ID(2)+API_PRIO(2)+MSG_LENGTH(4)+paramLen(2)+Payload(2)+RESERV(4) = 32 SRC_ID = TYPE_ID(8bit)+CPU_ID(4bit)+柜(4bit)+槽(8bit)+框(8bit)Payload: api_id(2,oam中添加,msg_id)+cIdGroupNumber(1)+enOpCode(1)+cIdGroupLength(4)+cIdNumber(1)+cId(2)+cIdLength(4) = 13 cIdGroupLength = 数据总长度 - CSPL_HEAD_SIZE - 8 cIdNumber = 数据条数 CSPL_HEAD+API_ID+cIdGroupNumber+enOpCode+cIdGroupLength+cIdNumber[2] + cId1 + cIdLength1 + 数据1 + cId2 + cIdLength2 + 数据2 DEVIP程序：ADD DEVIP: PN&#x3D;”1”,IP&#x3D;”1.1.1.2”,MASK&#x3D;”255.255.255.0”,VLAN&#x3D;”1”,AddressingType&#x3D;”Static”,Usage&#x3D;”SigPlan WebLMT消息下发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869CSPL_MAIN(mml) -&gt; initSectServ(循环接收消息：消息进入) -&gt; checkMsgSock(区分消息为心跳或请求) -&gt; req_cnnd(请求消息) -- readcmd(读取前台数据) -&gt; handleStmt(处理) -- parse(解析数据) -- trans(有些复杂未了解) -&gt;&gt; SendQuery(进入发送队列，唤醒其他线程) |CSPL_MAIN(lte_oam) //创建并注册各个实体(LayerEntity,CfgEntity) |oam_layer_intf_process_msg(实体：LayerEntity) -&gt; CSPL_SendMsg //根据api_id，配置module_id并转发至对应的模块(oam_cfg_intf_process_msg) |oam_cfg_intf_process_msg(实体：CfgEntity 注意：g_cfgMsgRspFunc-&gt;配置消息回应函数) -&gt; oam_cfg_msg_handle_req(全局变量未匹配到：cfg请求消息处理) -&gt; oam_cfg_msg_handle(全局变量未匹配到：处理配置消息) -- oam_cfg_msg_handle_add_del_mod(根据enOpCode执行对应的功能：增删改查配置消息) -&gt; oam_cfg_get_moduleID_and_apiID(根据motype获取module_id和api_id) -&gt; CSPL_SendMsg -- oam_cfg_ha_active_send_add_del_mod_msg -&gt; CSPL_HA_SendBoardMsg(发送板间消息) -- oam_cfg_ha_enb_db_submit(修改数据库) |CSPL_MAIN(lte_ncp) -- ncp_parse_trm_scheme_cfg_file(初始化全局变量g_LteSchemeVppFlg) --- ncp_init_trm_scheme_cfg_para --- ncp_trm_scheme_conf_parse_arr -&gt; ncp_parse_lte_scheme_vpp_flag -- ncp_init_local(初始化全局变量g_ncp_local) -- ncp_init_oam_driver(初始化NCP消息通信实体oam_msg_entity) --- ncp_init_oam_msg_addr(初始化CSPL通信地址，静态路由配置) --- ncp_init_oam_msg_driver(创建注册通信entity) -- ncp_int_module(初始化各功能模块) -&gt; g_module_init_array //创建并注册NCP与OAM通信实体(oam_msg_entity) |ncp_process_msg(实体：oam_msg_entity) -&gt; ncp_oam_process_msg(根据type_id执行对应的功能：oam ipc消息处理) -&gt; ncp_process_cfg_from_oam(根据api_id执行对应的功能：OAM配置消息处理) -&gt; ncp_send_cfg_to_agent(根据宏IS_AGENT_CFG执行对应功能：NCP发送配置信息给AGENT) -&gt; CSPL_SendMsg |CSPL_MAIN(lte_agent) -- agent_env_init(agent环境初始化) -&gt; ethname_init(eth名称初始化) -&gt; get_eth_name_from_cofig_file(从配置文件trm.cfg获取eth名称) -- agent_init_local(初始化全局变量g_agent_local) -- agent_init_oam_driver(初始化AGENT消息通信实体agent_msg_entity) --- agent_init_oam_msg_addr(初始化与OAM通信地址，静态路由配置) --- agent_init_oam_msg_driver(创建注册通信entity) -- agent_parse_trm_slot_num_mcb_cfg_file(从配置文件trp_slot_num_mcb.cfg中获取主控板MCB槽号) --- agent_init_trm_slot_num_mcb_cfg_para(设置默认槽号7) --- conf_parse_func(解析数据) -- pthread_create(创建va_start,agent_mo_proc_thread,agent_pm_proc_thread,agent_omch_dhcp_proc_thread四个线程) //创建并注册AGENT与OAM通信实体，创建agent_mo_proc_thread等线程 |agent_process_msg(实体：agent_msg_entity) -&gt; agent_ncp_process_msg(根据type_id执行对应的功能：ncp ipc消息处理) -&gt; agent_process_cfg_from_oam(根据api_id执行对应的功能：OAM配置消息处理) -&gt; agent_send_rsp_to_ncp(AGENT发送应答消息给NCP) -&gt; CSPL_SendMsg |agent_mo_proc_thread(MO处理线程) -&gt; agent_cfg_mo_proc_in_thread(MO配置信息处理) -- agent_add_devip(addFunc&gt;pAgentDeal&gt;agent_mo_ctx 。agent添加DEVIP) -&gt; kernel_add_del_static_devip(系统内核添加删除静态DEVIP) -&gt; EXEC_CAM_AND_FAIL_RETRY -&gt; exec_cmd(执行命令行命令) -(失败)- agent_add_re_deal_item agent消息回传1234567891011agent_send_rsp_to_ncp(封装消息头 和 有效载体，并进行发送) |ncp_process_msg -&gt; ncp_agent_process_msg |oam_layer_intf_process_msg |oam_cfg_intf_process_msg |OAM_SendMsgToNmsOrMML |initSectServ","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]},{"title":"电口与光口","slug":"电口与光口","date":"2023-08-29T05:47:41.000Z","updated":"2023-09-07T09:38:40.357Z","comments":true,"path":"2023/08/29/电口与光口/","link":"","permalink":"http://example.com/2023/08/29/%E7%94%B5%E5%8F%A3%E4%B8%8E%E5%85%89%E5%8F%A3/","excerpt":"","text":"1. 光口光口是服务器和网络中对各种光纤端口的统称，它是以光作为信息的承载介质。光口可能包含有从ST到SFF（小型化光纤连接器，以 MTRJ和LC为主）的各种光纤接口，因此在布线施工后期配备光纤跳线时，需要核实光口的光纤接口种类，以免在布线配置时假定的光纤跳线种类与实际使用的要求不匹。 光纤接口是用来连接光纤线缆的物理接口。其原理是利用了光从光密介质进入光疏介质从而发生了全反射。通常有SC、ST、FC等几种类型，它们由日本NTT公司开发。FC是Ferrule Connector的缩写，其外部加强方式是采用金属套，紧固方式为螺丝扣。ST接口通常用于10Base-F，SC接口通常用于100Base-FX。 2. 电口电口是服务器和网络中对RJ45等各种双绞线接口的统称，其原因是这些端口都使用电作为信息的承载介质，不过有时它也会包含同轴电缆端口。通常电口可能使用百兆以太网、千兆以太网、万兆以太网或其它种类的传输协议。 电口是相对光口来讲的，是指防火器的物理特性，主要指铜缆，包括普通的网线和射频同轴电缆，是处理的电信号。目前使用普遍的网络接口有百兆电口和千兆电口等。简单来说，电口就是普通的双绞线（Twirst Pair）接口，一般速率为10M或者100M，部分支持1000M.电口的最远距离为100米。光口的线缆上传输的是光信号，而电口的线缆上传输的是电信号，例如高电平（代表1），低电平（代表0）。 3. 区别光口和电口的用途都一样，都是对外通讯接口，起传输作用。简单一点说就只是传输介质的不同，光口接光纤，电口接普通通讯电缆，最大区别是要求通讯速度高的用光口，没那么高要求的用电口。 是纯物理层上的传输介质变换，其实就是光信号和电信号的转换。 光口就是我们通常说的带光板扩展槽的可以插入光纤，进行远距离数据传输，电口就是我们常说的RJ45的端口也就是网线口，带网管的交换机可以进行交换机的功能以及权限的管理和在线监控设备状态，并且带有网络登陆功能。非网管型就是傻瓜型插上线就直接用，一般仅仅只有二层交换功能。 155Mb&#x2F;s以下都是电接口，155Mb&#x2F;s以上都是光接口；155Mb&#x2F;s可以是电接口，也可以是光接口； 局内连接可以是电接口，也可以是光接口； 局间连接都是光传输； 电信号用同轴电缆连接。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"PTP简介","slug":"PTP简介","date":"2023-08-25T01:47:48.000Z","updated":"2023-09-07T09:38:40.472Z","comments":true,"path":"2023/08/25/PTP简介/","link":"","permalink":"http://example.com/2023/08/25/PTP%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1 网络时钟同步在通信网络中，许多业务的正常运行都要求网络时钟同步，即整个网络各设备之间的时间或频率差保持在合理的误差水平内。主要分为两种： 时间同步：也叫相位同步（Phase synchronization），是指信号之间的频率和相位都保持一致，即信号之间的相位差恒为零。 频率同步（Frequency synchronization）：也叫时钟同步，是指信号之间在频率或相位上保持某种严格的特定关系，信号在其对应的有效瞬间以同一平均速率出现，以保证通信网络中的所有设备都以相同的速率运行，即信号之间保持恒定的相位差。 2 PTP协议PTP（Precision Time Protocol，精确时间协议）是一种时间同步的协议，其本身只是用于设备之间的高精度时间同步，但也可被借用于设备之间的频率同步。相比现有的各种时间同步机制，PTP具备以下优势： 相比NTP（Network Time Protocol，网络时间协议），PTP能够满足更高精度的时间同步要求：NTP一般只能达到亚秒级的时间同步精度，而PTP则可达到亚微秒级。 相比GPS（Global Positioning System，全球定位系统），PTP具备更低的建设和维护成本，并且由于可以摆脱对GPS的依赖，在国家安全方面也具备特殊的意义。 3 PTP基本概念3.1 PTP域我们将应用了PTP协议的网络称为PTP域。PTP域内有且只有一个同步时钟，域内的所有设备都与该时钟保持同步。 3.2 PTP端口我们将设备上运行了PTP协议的端口称为PTP端口，可分为以下三种： 主端口（Master Port）：发布同步时间的端口，可存在于BC或OC上。 从端口（Slave Port）：接收同步时间的端口，可存在于BC或OC上。 被动端口（Passive Port）：既不接收同步时间、也不对外发布同步时间的端口，只存在于BC上。 3.3 时钟节点PTP域中的节点称为时钟节点，PTP协议定义了以下三种类型的基本时钟节点： OC（Ordinary Clock，普通时钟）：该时钟节点在同一个PTP域内只有一个PTP端口参与时间同步，并通过该端口从上游时钟节点同步时间。此外，当时钟节点作为时钟源时，可以只通过一个PTP端口向下游时钟节点发布时间，我们也称其为OC。 该时钟节点在同一个PTP域内拥有多个PTP端口参与时间同步。它通过其中一个端口从上游时钟节点同步时间，并通过其余端口向下游时钟节点发布时间。此外，当时钟节点作为时钟源时，可以通过多个PTP端口向下游时钟节点发布时间的，我们也称其为BC。 TC（Transparent clock，透明时钟）：与BC&#x2F;OC相比，BC&#x2F;OC需要与其它时钟节点保持时间同步，而TC则不与其它时钟节点保持时间同步。TC有多个PTP端口，但它只在这些端口间转发PTP协议报文并对其进行转发延时校正，而不会通过任何一个端口同步时间。TC包括以下两种类型： E2ETC（End-to-End Transparent Clock，端到端透明时钟）：直接转发网络中非P2P（Peer-to-Peer，点到点）类型的协议报文，并参与计算整条链路的延时。 P2PTC（Peer-to-Peer Transparent Clock，点到点透明时钟）：只直接转发Sync报文、Follow_Up报文和Announce报文，而终结其它PTP协议报文，并参与计算整条链路上每一段链路的延时。 除了上述三种基本时钟节点以外，还有一些混合时钟节点，譬如融合了TC和OC各自特点的TC+OC：它在同一个PTP域内拥有多个PTP端口，其中一个端口为OC类型，其它端口则为TC类型。一方面，它通过TC类型的端口转发PTP协议报文并对其进行转发延时校正；另一方面，它通过OC类型的端口进行时间的同步。与TC的分类类似，TC+OC也包括两种类型：E2ETC+OC和P2PTC+OC。 3.4 主从关系主从关系（Master-Slave）是相对而言的，对于相互同步的一对时钟节点来说，存在如下主从关系： 发布同步时间的节点称为主节点，而接收同步时间的节点则称为从节点。 主节点上的时钟称为主时钟，而从节点上的时钟则称为从时钟。 发布同步时间的端口称为主端口，而接收同步时间的端口则称为从端口。 3.5 最优时钟PTP域中所有的时钟节点都按一定层次组织在一起，整个域的参考时间就是最优时钟（Grandmaster Clock，GM），即最高层次的时钟。通过各时钟节点间PTP协议报文的交互，最优时钟的时间最终将被同步到整个PTP域中，因此也称其为时钟源。 最优时钟可以通过手工配置静态指定，也可以通过BMC（Best Master Clock，最佳主时钟）协议动态选举，动态选举的过程如下： 各时钟节点之间通过交互的Announce报文中所携带的最优时钟优先级、时间等级、时间精度等信息，最终选出一个节点作为PTP域的最优时钟，与此同时，各节点之间的主从关系以及各节点上的主从端口也确定了下来。通过这个过程，整个PTP域中建立起了一棵无环路、全连通，并以最优时钟为根的生成树。 此后，主节点会定期发送Announce报文给从节点，如果在一段时间内，从节点没有收到主节点发来的Announce报文，便认为该主节点失效，于是重新进行最优时钟的选择。 4 PTP同步原理PTP同步的基本原理如下：主、从时钟之间交互同步报文并记录报文的收发时间，通过计算报文往返的时间差来计算主、从时钟之间的往返总延时，如果网络是对称的（即两个方向的传输延时相同），则往返总延时的一半就是单向延时，这个单向延时便是主、从时钟之间的时钟偏差，从时钟按照该偏差来调整本地时间，就可以实现其与主时钟的同步。 PTP协议定义了两种传播延时测量机制：请求应答（Requset_Response）机制和端延时（Peer Delay）机制，且这两种机制都以网络对称为前提。 4.1 请求应答机制 请求应答方式用于端到端的延时测量。其实现过程如下： 主时钟向从时钟发送Sync报文，并记录发送时间t1；从时钟收到该报文后，记录接收时间t2。 主时钟发送Sync报文之后，紧接着发送一个携带有t1的Follow_Up报文。 从时钟向主时钟发送Delay_Req报文，用于发起反向传输延时的计算，并记录发送时间t3；主时钟收到该报文后，记录接收时间t4。 主时钟收到Delay_Req报文之后，回复一个携带有t4的Delay_Resp报文。 此时，从时钟便拥有了t1～t4这四个时间戳，由此可计算出主、从时钟间的往返总延时为[(t2 – t1) + (t4 – t3)]，由于网络是对称的，所以主、从时钟间的单向延时为[(t2 – t1) + (t4 – t3)] &#x2F; 2。因此，从时钟相对于主时钟的时钟偏差为：Offset &#x3D; (t2 – t1) - [(t2 – t1) + (t4 – t3)] &#x2F; 2 &#x3D; [(t2 – t1) - (t4 – t3) ] &#x2F; 2。 此外，根据是否需要发送Follow_Up报文，请求应答机制又分为单步模式和双步模式两种： 在单步模式下，Sync报文的发送时间戳t1由Sync报文自己携带，不发送Follow_Up报文。 在双步模式下，Sync报文的发送时间戳t1由Follow_Up报文携带。 4.1 端延时机制 与请求应答机制相比，端延时机制不仅对转发延时进行扣除，还对上游链路的延时进行扣除。其实现过程如下： 主时钟向从时钟发送Sync报文，并记录发送时间t1；从时钟收到该报文后，记录接收时间t2。 主时钟发送Sync报文之后，紧接着发送一个携带有t1的Follow_Up报文。 从时钟向主时钟发送Pdelay_Req报文，用于发起反向传输延时的计算，并记录发送时间t3；主时钟收到该报文后，记录接收时间t4。 主时钟收到Pdelay_Req报文之后，回复一个携带有t4的Pdelay_Resp报文，并记录发送时间t5；从时钟收到该报文后，记录接收时间t6。 主时钟回复Pdelay_Resp报文之后，紧接着发送一个携带有t5的Pdelay_Resp_Follow_Up报文。 此时，从时钟便拥有了t1～t6这六个时间戳，由此可计算出主、从时钟间的往返总延时为[(t4 – t3) + (t6 – t5)]，由于网络是对称的，所以主、从时钟间的单向延时为[(t4 – t3) + (t6 – t5)] &#x2F; 2。因此，从时钟相对于主时钟的时钟偏差为：Offset &#x3D; (t2 – t1) - [(t4 – t3) + (t6 – t5)] &#x2F; 2。 此外，根据是否需要发送Follow_Up报文，端延时机制也分为单步模式和双步模式两种： 在单步模式下，Sync报文的发送时间戳t1由Sync报文自己携带，不发送Follow_Up报文；而t5和t4的差值由Pdelay_Resp报文携带，不发送Pdelay_Resp_Follow_Up报文。 在双步模式下，Sync报文的发送时间戳t1由Follow_Up报文携带，而t4和t5则分别由Pdelay_Resp报文和Pdelay_Resp_Follow_Up报文携带。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"volantis","slug":"volantis","date":"2023-08-24T10:45:13.000Z","updated":"2024-11-18T02:55:09.458Z","comments":true,"path":"2023/08/24/volantis/","link":"","permalink":"http://example.com/2023/08/24/volantis/","excerpt":"","text":"常用指令12345hexo new &quot;FileName&quot; #Create a new posthexo clean #Clean the cached file db.json and the generated static file publichexo generate #Generate static fileshexo server #Run serverhexo deploy #deploy to remote 美化设计1. 更换头像Hexo默认的文件位置在&#x2F;blog&#x2F;source文件目录下，因此如果在source文件夹下新建了一个images文件夹用来存放所有博客需要的图片文件。例如我使用QQ.jpg作为我的头像，那么我需要在_config.volantis.yml中的sidebar项widget_library项中的avatar设置为&#x2F;images&#x2F;QQ.jpg。 文章编辑1. Front-matter使用https://hexo.io/zh-cn/docs/front-matter","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"网络传输协议（二）","slug":"网络传输协议（二）","date":"2023-08-24T02:13:48.000Z","updated":"2023-09-07T09:38:40.357Z","comments":true,"path":"2023/08/24/网络传输协议（二）/","link":"","permalink":"http://example.com/2023/08/24/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"协议：ARP，DHCP和ICMP 4. ARP4.1 ARP的作用ARP（Address Resolution Protocol，地址解析协议）是将IP地址解析为以太网MAC地址（或称物理地址）的协议。在局域网中，当主机或其它网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送，因此发送站还必须有接收站的物理地址，所以需要一个从IP地址到物理地址的映射。APR就是实现这个功能的协议。 4.2 ARP报文结构ARP报文分为ARP请求报文和ARP应答报文，报文格式如下： 硬件类型：表示硬件地址的类型。它的值为1表示以太网地址； 协议类型：表示要映射的协议地址类型。它的值为0x0800即表示IP地址； 硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4； 操作类型（OP）：1表示ARP请求，2表示ARP应答； 发送端MAC地址：发送方设备的硬件地址； 发送端IP地址：发送方设备的IP地址； 目标MAC地址：接收方设备的硬件地址。 目标IP地址：接收方设备的IP地址。 4.3 ARP地址解析过程假设主机A和B在同一个网段，主机A要向主机B发送信息： 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。 当主机A和主机B不在同一网段时： 主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。 4.4 ARP表设备通过ARP解析到目的MAC地址后，将会在自己的ARP表中增加IP地址到MAC地址的映射表项，以用于后续到同一目的地报文的转发。ARP表项分为动态ARP表项和静态ARP表项。 动态ARP表项 动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。当到达老化时间、接口down时会删除相应的动态ARP表项。 静态ARP表项 静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时只使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，从而保护了本设备和指定设备间的正常通信。 4.5 免费ARP免费ARP报文是一种特殊的ARP报文，该报文中携带的发送端IP地址和目标IP地址都是本机IP地址，报文源MAC地址是本机MAC地址，报文的目的MAC地址是广播地址。设备通过对外发送免费ARP报文来实现以下功能： 确定其它设备的IP地址是否与本机的IP地址冲突。当其它设备收到免费ARP报文后，如果发现报文中的IP地址和自己的IP地址相同，则给发送免费ARP报文的设备返回一个ARP应答，告知该设备IP地址冲突。 设备改变了硬件地址，通过发送免费ARP报文通知其它设备更新ARP表项。 4.5.1 免费ARP报文学习功能的作用使能了免费ARP报文学习功能后，设备会根据收到的免费ARP报文中携带的信息（源IP地址、源MAC地址）对自身维护的ARP表进行修改。设备先判断ARP表中是否存在与此免费ARP报文源IP地址对应的ARP表项： 如果没有对应的ARP表项，设备会根据该免费ARP报文中携带的信息新建ARP表项； 如果存在对应的ARP表项，设备会根据该免费ARP报文中携带的信息更新对应的ARP表项。 关闭免费ARP报文学习功能后，设备不会根据收到的免费ARP报文来新建ARP表项，但是会更新已存在的对应ARP表项。如果用户不希望通过免费ARP报文来新建ARP表项，可以关闭免费ARP报文学习功能，以节省ARP表项资源。 4.5.2 定时发送免费ARP功能的作用定时发送免费ARP功能可以及时通知下行设备更新ARP表项或者MAC地址表项，主要应用场景如下： 防止仿冒网关的ARP攻击 防止主机ARP表项老化 防止VRRP虚拟IP地址冲突 及时更新模糊终结VLAN内设备的MAC地址表 4.6 代理ARP如果ARP请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程称作代理ARP（Proxy ARP）。代理ARP功能屏蔽了分离的物理网络这一事实，使用户使用起来，好像在同一个物理网络上。代理ARP分为普通代理ARP和本地代理ARP，二者的应用场景有所区别： 普通代理ARP的应用环境为：想要互通的主机分别连接到设备的不同三层接口上，且这些主机不在同一个广播域中。 本地代理ARP的应用环境为：想要互通的主机连接到设备的同一个三层接口上，且这些主机不在同一个广播域中。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"大端序与小端序","slug":"大端序与小端序","date":"2023-08-23T09:04:11.000Z","updated":"2023-09-07T09:38:40.357Z","comments":true,"path":"2023/08/23/大端序与小端序/","link":"","permalink":"http://example.com/2023/08/23/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/","excerpt":"","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下： Big-endian：高位字节存入低地址，低位字节存入高地址 Little-endian：低位字节存入低地址，高位字节存入高地址 例如，将12345678h写入1000h开始的内存中，以大端序和小端序模式存放结果如下： 一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"GDB常用调试命令","slug":"GDB常用调试命令","date":"2023-08-17T10:12:44.000Z","updated":"2025-04-23T08:33:39.586Z","comments":true,"path":"2023/08/17/GDB常用调试命令/","link":"","permalink":"http://example.com/2023/08/17/GDB%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令 调试命令（缩写） 作用 break (b) xxx 在源代码指定的某一行设置断点，其中xxx用于指定具体打断点位置。 run (r) 执行被调试的程序，其会自动在第一个断点处暂停执行。 continue (c) 当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束。 next (n) 令程序一行代码一行代码的执行。 step (s) 如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样。 until (u) 在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体。 until (u) n n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止。 print (p) 打印指定变量的值，其中 xxx 指的就是某一变量名。 list (l) 显示源程序代码的内容，包括各行代码所在的行号。 finish (f) 结束当前正在执行的函数，并在跳出函数后暂停程序的执行。 return (return) 结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行。 jump (j) 使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码。 quit (q) 终止调试。 回车 执行上一条指令 调试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 进程编译gcc -g -O0 &#123;program.c&#125; -o &#123;program&#125; # -g: 待调试信息编译 -O0: -O表示优化编译，优化级别：0（不优化）readelf -S &#123;program&#125; | grep debug # 检查进程是否带调试信息objdump -g &#123;program&#125; # 检查进程是否带调试信息# 查看core文件file core.23118gdb lte_trps core.23118btf 4# 附加进程gdb attach `pidof lte_trps`gdb -p `pidof lte_trps`# 拉起进程ROOT=&quot;/LTE&quot;export LD_LIBRARY_PATH=$ROOT/user/Area0/bin:$ROOT/user/Area0/lib:/opt/lte/tools/usr/lib/:$LD_LIBRARY_PATHgdb ./lte_trpsrun 10.11.1.130:10157 10.11.1.130:15003gdb --args lte_trps 10.11.1.130:10157 10.11.1.130:15003run# 断点管理break &#123;funcname&#125; # 在 funcname 函数设断点break &#123;file&#125;:linenum # 在 file 第 linenum 行设断点 break *0x4005a0 # 在内存地址设断点info breakpoints # 查看所有断点delete &#123;ID&#125; # 删除断点# 执行控制continue (c) # 继续运行到下一个断点next (n) # 执行下一行（不进入函数）step (s) # 执行下一行（进入函数）finish (f) # 执行完当前函数并暂停# 查看变量、内存、堆栈、寄存器info locals # 显示当前函数（当前堆栈帧）中所有局部变量的值print &#123;var&#125; # 显示变量值（十进制）print /x &#123;var&#125; # 十六进制显示print *(int*)&#123;0xaddr&#125; # 强制转换内存地址内容x /4x &amp;&#123;var&#125; # 以十六进制显示 4 个字节x /s &#123;0xaddr&#125; # 显示字符串（直到 NULL）x /10i $pc # 显示当前 10 条汇编指令backtrace (bt) # 显示调用栈frame &#123;ID&#125; # 切换到指定堆栈帧info registers # 显示所有寄存器print $rax # 显示 RAX 寄存器的值# 多线程调试info threads # 查看所有线程thread &#123;ID&#125; # 切换到指定线程# 观察捕获watch &#123;var&#125; # 变量被修改时暂停watch *(int*)&#123;0xaddr&#125; # 监视内存地址catch throw # 捕获 C++ 异常# 其他命令set &#123;var&#125; = 10 # 修改变量为 10set print pretty on # 美化结构体输出quit (q) # 退出调试help &#123;command&#125; # 查看命令帮助","categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"IPSec-VPN","slug":"IPSec-VPN","date":"2023-08-15T06:21:36.000Z","updated":"2023-09-07T09:38:40.472Z","comments":true,"path":"2023/08/15/IPSec-VPN/","link":"","permalink":"http://example.com/2023/08/15/IPSec-VPN/","excerpt":"","text":"1. VPN简介隧道： 是利用一种协议来传输另外一种协议的技术，共涉及三种协议，包括：乘客协议、隧道协议和承载协议。 VPN（Virtual Private Network，虚拟专用网）： 就是利用开放的公众IP&#x2F;MPLS网络建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。实质是通过隧道技术在公众IP&#x2F;MPLS网络上仿真一条点到点的专线 。 2. IPSec2.1 IPSec简介IPSec： 是一种开放标准的框架结构，特定的通信方之间在IP层通过加密和数据摘要(hash)等手段，来保证数据包在Internet 网上传输时的私密性(confidentiality) 、完整性(data integrity)和真实性(origin authentication)。IPSec只能工作在IP层，要求乘客协议和承载协议都是IP协议。 对称加密： 加密密钥与解密密钥相同。由于对称加密的运算速度快，所以IPSec使用对称加密算法来加密数据。hash运算： 对数据和密钥一起进行处理，保证完成性的同时抵御外部攻击。DH算法： 完成对称密钥的交换。 身份认证： 保证数据的真实性。常用的身份认证方式包括：Pre-shared key（预共享密钥）、RSA Signature（数字签名）。 2.1 IPSec框架结构 2.2 IPSec封装模式IPSec支持两种封装模式：传输模式和隧道模式。(1). 传输模式：不改变原有的IP包头，通常用于主机与主机之间。 (2). 隧道模式：增加新的IP头，通常用于私网与私网之间通过公网进行通信。 2.3 IPSec与NATAH模式无法与NAT一起运行: AH对包括IP地址在内的整个IP包进行hash运算，而NAT会改变IP地址，从而破坏AH的hash值。 只进行地址映射时，ESP可与它一起工作。 进行端口映射时，需要修改端口，而ESP已经对端口号进行了加密或hash，所以将无法进行。 启用IPSec NAT穿越后，会在ESP头前增加一个UDP头，就可以进行端口映射。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"4G-LTE（二）","slug":"4G-LTE（二）","date":"2023-08-11T07:21:20.000Z","updated":"2023-09-07T09:38:40.356Z","comments":true,"path":"2023/08/11/4G-LTE（二）/","link":"","permalink":"http://example.com/2023/08/11/4G-LTE%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"2. LTE EPC与eNodeB之间采用S1接口。S1接口是基站（无线网）与核心网之间的接口，包含两种接口： S1-U：用户面，用来连接eNB与SGW，用于传送业务数据 S1-MME：用来连接eNB与MME，用于传送信令 eNodeB与eNodeB之间采用X2接口，包含两种： X2-U ：用户面 X2-CP : 控制面 X2-U与X2-CP虽然是不同的逻辑端口，但通常是同一个物理端口。 2.1 S1-U接口与协议GTP-U用于承载用户面的数据包。 GTP协议本质是一种IP包的封装协议。IP数据包经过GTP协议的封装，可以在LTE核心网传输。S1-U接口上存在多个数据流的复用，数据流用TEID(Tunnel EndPoint IDentifier，隧道端点IP) 来区分。 2.2 S1-MME接口与协议S1-MME接口用于承载信令。 SCTP协议是流控传输协议。S1-AP协议对应S1-MME接口的主要功能。 2.3 X2-U接口与协议X2-U接口用以承载业务数据。x2-U协议栈结构与S1-U一致。 2.4 X2-CP结构与协议X2-CP接口用于承载信令。 2.5 LTE网络架构分为四个部分：终端（UE）、接入网（E-UTRAN）、核心网（EPC）、公共网（PDN） UE是我们的手机或CPE，E-UTRAN是遍布城市的各个基站（可以是大的铁塔基站，也可以是室内悬挂的只有路由器大小的小基站），EPC是运营商（中国移动&#x2F;中国联通&#x2F;中国电信）的核心网服务器，核心网包括很多服务器，有处理信令的、数据的、计费策略的等等，PDN即公网，如各个网站、游戏、视频的服务器。 UE到eNB这一段是无线的，我们称这一段网络叫空中接入网；eNB之间、eNB和EPC之间都是LTE的内部网络，使用光纤相连接；EPC和PDN这一段叫地面网，使用光纤相连接，是LTE与公网的出入口。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"网络传输协议（一）","slug":"网络传输协议（一）","date":"2023-08-10T02:55:30.000Z","updated":"2023-09-07T09:38:40.414Z","comments":true,"path":"2023/08/10/网络传输协议（一）/","link":"","permalink":"http://example.com/2023/08/10/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"协议：TCP, UDP和SCTP TCP&#x2F;IP协议族如图： TCP&#x2F;IP协议族除了TCP和IP协议外，还包括许多其他协议。如UDP, ICMP, ARP, SCTP 1. UDPUDP（User Datagram Protocol，用户数据报协议）。一个无连接协议，尽力而为传输。传输单位UDP数据报。使用的套接字为数据报套接字。 进程在套接字写入一个消息（应用层），该消息随后被封装到一个UDP数据报（传输层），该数据报进而被封装到IP数据报（网络层），发往目的地。UDP不保证按需交付，而且不保证每个数据报只到达一次。 不同于TCP无边界的字节流，UDP的数据报都有一个长度。 无连接的。意味着一个UDP client和server之间不用存在长期关系。一个client可以创建一个UDP socket并用它前后发送多个数据报给多个服务器。同理，一个server也可以用一个socket来从不同的客户端接收数据。 2. TCPTCP（Transmission Control Protocol, 传输控制协议）。一个面向连接的协议，提供可靠的全双工字节流。使用的套接字为流套接字。 在描述TCP连接的建立和释放前，需要说明。网络编程中连接的建立和释放基本上都是由客户端（应用程序）主动发起。 TCP连接建立—三次握手： TCP连接释放—四次挥手： 客户端主动调用close，向服务器发送一个FIN分节，表示自己的数据发送完毕； 服务器收到FIN后返回ACK，表示自己收到客户端关闭连接的请求；【此时只有客户端连接关闭】 服务器完成针对该客户端的服务后调用close关闭其服务进程。服务器向客户端发送一个FIN表示自己的服务应答数据发送完毕； 客户端返回一个ACK表示确认。【此时双方连接都关闭】 TCP为应用程序提供面向连接的可靠服务，用于OM通道的传输承载。TCP通过如下特征来实现此目标： 差错控制：TCP通过累积的确认信息来报告丢失的分段或接收端分组的失序，通过超时和重传机制来确保应用程序数据的可靠接收。 流量控制：TCP用滑动窗口流量控制机制来防止接收缓冲区的溢出。 拥塞控制：TCP通过慢启动（slow start）、拥塞避免（congestion avoidance）和快速重传&#x2F;快速恢复（fast retransmit &#x2F; fast recovery）机制来适应路由器的阻塞，以获得高吞吐量。 3. SCTP（Stream Control Transport Protocol）流控制传输协议3.1 传统传输协议的弊端：TCP 由于严格的顺序递交和确认重传带来了额外的传输流量和较大的时延UDP 又因为过于简单，缺少必要的可靠传输保证，容易导致网络拥塞甚至崩溃 3.2 SCTP 的特征 内建多地址主机支持：SCTP 中的一对连接称为关联（Association），关联两端的主机节点（Endpoint）可以有多个网络地址，从而使一个 SCTP 关联可以通过多条网络路径进行数据传输。 保留应用层消息边界：SCTP 保留上层数据信息的边界，上层数据信息称为“消息”，传输的基本单位为有意义的数据段。 单个关联（Association）多流机制：SCTP 允许用户在每个关联中定义子流，数据在子流内按序传输。 3.3 SCTP 数据包格式SCTP 提供了灵活的数据块格式，每个 SCTP 数据报都由一个 Common Header（基本首部）和若干 Chunk（数据块）组成。 基本首部提供了源端口和目的端口，用于完成典型的传输层协议端口复用功能；验证标记对一个 SCTP 连接提供安全验证，保存着在 SCTP 通过握手建立连接时第一次交换的初始标签的值。在一次连接中，任何 SCTP 数据包若不包含这样一个标签，到达时会被接收端丢弃。 校验和是对整个数据包的校验。 在首部后是一系列 Chunks （块）。Chunk 是组成 SCTP 报文的基本结构，有多种类型，不同类型的块可用来传输不同的控制信息或数据；同时首部中的 F(flags) 标记字段提供了额外的控制信息。 丰富的 Chunk 类型使 SCTP 可以采用不同类型的 Chunk 实现各种传输控制机制。 3.4 SCTP 的消息（message）和流（stream）SCTP 协议将上层数据信息称为用户消息（user message），在传输中 SCTP 保留上层数据信息的边界，传输的基本单位为有意义的数据段。因此 SCTP 称为“面向消息”的传输协议。 SCTP 提出了数据流的概念，每个数据块中不仅有传输序号 TSN，还携带了流标识 SID（Stream ID）和流序号 SSN（Stream Sequence Number）。 用户可以在一个连接中建立多个流，每个流分配一个 SID，每个流队列中的用户数据由流序号 SSN 表明顺序。 在 SCTP 中引入一个连接多个流的机制解决了使用 TCP 传输时出现的队首阻塞问题。 允许某些应用程序根据需求将逻辑上不相关的数据分离为多个流进行传输往往很有意义，如一个多媒体视频会议系统中的多路语音信号在各自的流中传输，彼此之间不会互相阻塞。 flags 字段共三位，其中的 U 位为是否按序递交用户消息的标志，B、E 位分别代表本 Data Chunk 包含一个用户消息的开始或结束，如果本数据块包含一条完整的用户消息，则 BE 都置为 1，如包含消息中间的内容则都置为 0。 SCTP 提供按序递交和无序递交两种选择，Data Chunk 中的flags 字段中的 U 位就表明了该数据所需要的服务是按序递交或是无序递交。当采用无序递交时，SCTP 就具有了类似 UDP 的一些特征，能够尽快的将数据发往上层，适用于一些实时应用。 实际上，通过引入流和无序递交机制，SCTP 实现了严格有序传输（类似 TCP），部分有序传输（部分流内无序递交）和无序传输（类似 UDP）。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"CSPL架构","slug":"CSPL架构","date":"2023-08-09T05:18:02.000Z","updated":"2023-09-07T09:38:40.472Z","comments":true,"path":"2023/08/09/CSPL架构/","link":"","permalink":"http://example.com/2023/08/09/CSPL%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1.CSPL架构简述CSPL的定位和目的： CSPL位于业务与操作系统之间 屏蔽操作系统的复杂接口，提供统一的操作方式，使得业务进程只需要关心本身业务，从而加速协议栈的开发 CSPL核心是以lib库（动态库、静态库）的形式提供给业务，同时为了支撑业务，提供多个进程支撑；DAEMON、LOG、CLI、HA CSPL Core Stack Porting Layer 核心系统接口层 OSAL Operating System Adapter Layer 操作系统适配层 任务管理 任务调度管理等功能，提供统一的运行调度机制 内存管理 提供内存池，高端内存等功能 消息通信 提供任务间的消息通信处理等功能，如UDP、TCP、消息队列等 系统调试 提供Log、信令跟踪、黑匣子、运行时调试，性能统计等功能 事件管理 提供事件服务器，支持事件订阅、发布操作 其他功能 提供定时器，数据库，CLI调试等功能 2.CSPL设计思路2.1模型抽象2.1.1数据结构QMANIFEST 每一个协议栈实例（模块）由QMANIFEST数据结构来表示，CSPL通过此数据结构来和协议栈交互， CSPL_RegisterModule函数使用此结构体向CSPL注册module 12345678910111213141516171819typedef struct QMANIFEST&#123; const char *name; //模块名称 unsigned long service; //模块ID struct &#123; void *(*early)(void *); //模块早期初始化函数，不能发消息，不能启动定时器 void *(*late)(void *); //模块后期初始化函数，可以发消息，和启动定时器 &#125; init; //初始化函数 struct &#123; int (*message)(void *, void *); //消息处理函数，需要返回1 void (*timer)(QTIMER, void *, void *); //定时器处理函数 &#125; handler; //消息、定时器处理入口 struct &#123; void *(*pack)(QMODULE, void *, unsigned int *); void *(*unpack)(QMODULE, void *); void *(*alloc)(QMODULE, unsigned int); &#125; method; //消息编解码函数 const unsigned long *destinations; //外部交互模块&#125; QMANIFEST; cspl_address_t 每一个协议栈路由信息用cspl_address_t数据结构来表示，CSPL_Open内部通过此数据结构来配置本地接收和发送的路由（即创建相应的fd， 并加入到epoll中） 123456789101112typedef struct&#123; route_type_et type; //接收或者发送0:recv 1:send 2:trace（暂时不支持） trans_type_et transType; //传输类型0:UDP 1:TCP 2:msg queue消息队列为POSIX版本3：LINX U8 isStripCspIHead; //该字段仅对外部模块起作用 U32 moduleId; //模块ID号，如果是接收，则当没有CSPL头的消息转发到该模块 union&#123; U8 ipAddress[CSPL_IP_ADDRESS_LENGTH]; //ip地址加端口号，类似127.0.0.1::6700 U8 mqName[CSPL_MQ_NAME_LENGTH]; //消息队列的名称。类似“/RrmToMac%d:1024” 后面的数字作为消息最大长度值，如果没有，则使用默认配置 U8 endPoint[CSPL_LINX_ENDPOINT_LENGTH]; //LINX endpoint名称的最大长度 U8 rawType[CSPL_IP_ADDRESS_LENGTH]; //原始套接字类型，可选值：UDP、TCP、ICMP、IGMP &#125;address;&#125;cspl_address_t; //open的时候传入该数组 qvars qvars结构体用于描述driver，当模块未设置立即发送标志时，hold队列用于存放所有的发送消息，当本driver调度运行时，会将所有hold消息都发送出去。 12345678910typedef struct qvars&#123; YLNODE __header__; //driver节点，挂载到qcontext的driverloops双链表上 QMODULE self; //driver当前的处理的module指针 YSQUEUE queue; //接收消息优先级队列 YSQUEUE hold; //发送消息优先级队列 YLIST modules; //module双链表 void (*wakeup)(void *); //用于唤醒driver，对应于QWAIT wakeup void *argwakeup;&#125;qvars; QSHELL QSHELL结构体用于适配不同的操作系统， 属于OSAL层。使用多路复用IO模型，内部使用epoll完成对多路事件的监控。 12345678910struct QSHELL&#123; void (*timedwait)(void *, const QTIME); //睡眠等待指定的时间，若所监控的描述符数组中有事件发生（epoll），则结束睡眠 void (*send)(void *, const void *, QMODULE, QMODULE, void *, unsigned int); //将消息发送到指定的外部模块 void (*receive)(void *, const void *, QMODULE *, QMODULE *, signed char *); //扫描监听的描述符数组，从fd可读事件中读取所有消息 //receive内部调用epoll_wait时传入的时间参数为0，是非阻塞调用 void *(*open)(void *); //依据形参中cspl_address_t信息创建发送、接收路由 //每一条路由信息实际都对应着一个fd，并加入到epoll的监听数组中 void (*close)(void *); //关闭路由 void *(*hash)(void *, void *);&#125;; QWAIT QWAIT结构体用于适配不同的操作系统， 属于OSAL层。使用条件变量+互斥锁，完成driver的睡眠与唤醒操作。 123456struct QWAIT&#123; void *(*newchannel)(void); //新建一个条件变量+互斥锁 void (*sleep)(void *, const QTIME *); //driver睡眠指定的时间 void (*wakeup)(void *); //唤醒driver void *(*walltime)(QTIME *); //获取当前系统启动后的累加时间&#125;; walltime内部使用clock_gettime(CLOCK_MONOTONIC, &amp;ts)获取系统时间，此时间为单调递增时间，避免系统时间修改后， 对定时器造成影响。 newchannel中创建的条件变量使用函数pthread_condattr_setclock(&amp;condattr, CLOCK_MONOTONIC);来避免系统时间修改所造成的影响 QSYSOP QSYSOP结构体用于适配不同的操作系统， 属于OSAL层。使用linux线程局部存储设施来存放每个线程都具有的信息 12345678910111213typedef struct&#123; void *(*malloc)(unsigned int); void (*free)(void *); void *(*newkey)(void); //pthread_key_create void *(*getkey)(void *); //pthread_getspecific void (*setkey)(void *, void *); //pthread_setspecific void (*destroylock)(void *); void (*lock)(void *); //pthread_mutex_lock void (*unlock)(void *); //pthread_mutex_unlock int (*vprintf)(const char *, va_list); int (*iprintf)(const char *, va_list); void (*abort)(void);&#125;QSYSOP; 2.1.2运行模式 单线程 一个domain（进程）只有一个driver，所有module（协议栈模块）运行在一个driver内 driver驱动协议栈运行，同时负责对外通信（收发消息） 多线程 一个domain有多个driver，module（协议栈模块）分散运行在多个driver上 domain内有一个主driver负责对外通信（收发消息） 多线程+IndependDriver 一个domain有多个driver，module（协议栈模块）分散运行在多个driver上 domain内有一个主driver负责对外通信（收发消息） domain内还有独立的driver可以单独接收外部数据 2.2通信机制CSPL提供消息循环，各协议模块(module)之间基于消息进行通信： 内部模块（进程内）之间通过线程调度通信。 基于链表实现，直接传递消息指针，消息处理支持零拷贝，引用计数等特性。 与外部模块通信基于OS的IPC机制，比如socket。 采用钩子注册机制，可以选择UDP、TCP、Linx、消息队列等具体机制。 对每个外部模块可以单独注册通信函数。 对每个外部模块可以选择不同的通信方式，比如板内选择消息队列，板间选择UDP socket。 CSPL通讯抽象为driver内通信，driver之间通信，domain(进程)之间通信。 driver有发送消息(hold)和接收消息(queue)优先级队列，qvSchdule运行时，从接收消息队列上取出消息进行处理(qmodule-&gt;messageservice)， 从发送队列取出消息发送出去(qmodule-&gt;dispatch，仅在非立即发送模式下) 2.3消息格式 有效载荷长度：loadSize &#x3D; payload + CSPL_HEADER_SIZE 2.4内存管理CSPL_AllocMsg：用于申请cspl消息内存结构 接收cspl消息使用此函数申请内存，将接收到的cspl消息(cspl header + payload)打包后， 投递到目的module所对应的driver接收优先级队列中 发送cspl消息在此函数的返回值位置后面构造cspl header、填充消息payload后， 使用CSPL_SendMsg将消息发送到目的module 2.5启动流程及默认模块 CSPL_Init初始化时，会创建一个独立的driver，注册到此driver上的模块及功能如下： monitorEntity模块初始化定时器，每隔5s遍历所有driver，获取每个driver上发送、接收队列中所有消息的数目；若有超时的消息，则回调msgTimeoutCallback接口函数；若业务有消息或者定时器消息阻塞，则回调userDeadLoopCallback接口函数；若接收队列消息数目&gt;maxPendRecvMsg，则回调driverMsgOverLoadCallback接口函数；最后回调totalMsgOverLoadCallback接口函数。 debugEntity模块调用以DebugInfo结尾的调试函数，并回传执行结果(重定向)到cliDebug进程；全局变量打印及修改(宏和const变量除外)。 haEntity模块用于主备切换。 eventEntity模块用于实现事件初始化、发布、订阅、分发功能。事件客户端、服务器代码运行于此模块中。 2.6版本信息 查看版本号12strings libcspl_interface.a | grep V10V10R02CA1.B002 查看编译时间12strings libcspl_interface.a | grep csplBuildTimecsplBuildTime: 2017-03-28 14:16:07 3.CSPL组件3.1事件服务CSPL提供一种事件服务机制，任何业务都可以作为事件发布者和事件订阅者。 事件初始化业务使用CSPL_EventInit初始化事件，事件服务端记录所有的事件订阅信息。 事件订阅业务使用CSPL_EventSubscribe订阅事件，当事件发布者在某个时候发布此事件后，订阅者就会eventEntity模块中回调已注册的回调函数。 事件发布业务使用CSPL_EventPublish发布事件，当事件类型不为进程内类型时，事件会被发送到事件服务器，之后事件服务器再转发此事件到订阅此事件的所有业务进程中。 事件服务器位于lte_log进程中的eventEntity模块内，负责管理事件的订阅、取消订阅、事件转发操作。 心跳机制及订阅恢复机制： 事件服务器每隔3s就会向所有已经注册的事件客户端发送一次心跳事件；若客户端连续超过3次没有收到心跳，重新向事件服务端注册业务地址。当重新注册成功，恢复心跳，则遍历客户端中LocalDatalist链表，将已订阅的事件重新向服务端订阅。（事件客户端、服务器均运行在cspl中的eventEntity模块内） 3.2日志服务 日志和注册日志；日志信息保存为本地文件，支持日志文件加密，压缩CSPL_Log输出普通日志信息，保存到公用的日志文件中，如log.datCSPL_Slog输出的注册日志信息，保存到指定的日志文件中，由cspl_config.xml中registerLogCfg标记配置 支持设置日志过滤条件可按照模块ID、日志级别、进程名称来过滤日志 实时输出到本地终端、tcp client显示（远端实时显示）PC端日志服务器可通过tcp连接到lte_log上，实时获取日志信息，并保存到磁盘上 自定义类型日志-内存日志CSPL_MemLog可自定义日志的消息格式，满足业务特殊的需求，由cspl_config.xml中memLogCfg标记配置 当日志文件大小超出配置值时，自动创建对应的压缩文件，并控制压缩文件的数量在配置值范围内 事件服务器目前部署在日志进程内 dataProcess 此线程处理tcp的链接，客户端请求获得日志实时数据 cfgProcess 此线程处理tcp的链接，解析传递过来的命令，实现查询日志记录；查询、设置当前过滤规则；查询、设置实时开关等配置功能 loopProcess 处理CSPL_Log、CSPL_Slog等相关函数产生的日志、注册日志，并依据实时开关配置决定是否实时输出日志信息；保存日志信息到磁盘上 mem_log_proc 处理CSPL_MemLog内存日志信息；保存内存日志到磁盘 log_tarSystemCmd 当日志文件大小大于配置值时，压缩日志文件，并记录压缩文件个数，删除超出maxSaveCounts（压缩保存文件最大个数）之外的压缩文件 cspl默认线程 处理cspl相关的一些操作， 如事件服务器等 clidebug默认线程 处理clidebug相关的一些操作，启动clidebug服务器 3.3cliDebugclidebug用于在被调试进程运行时调试此进程，获取被调试进程的调试信息、内部运行状态等相关信息；clidebug配置文件为cspl_cliDebug_config.xml clidebug在连接被调试进程时，被调试进程必须已经在运行状态，必须明确被调试进程函数名称、调试ip、端口信息(若未指定，则使用配置文件中的配置值) 1clidebug -t 127.0.0.1:62001 -p lte_oam 调用基本命令1如ps、ls、ifconfig、pwd、cd、ping、quit、file、kill、help 、log_tool等 历史记录，可调试状态下支持20条命令记录，上下键切换 全局变量打印及修改（宏和const变量除外） 调用cspl自身维测接口(尚在开发中)1cspl_timer、cspl_event等 调用业务进程通过CSPL_CliDebug_RegCmd自行注册的函数或程序中以DebugInfo结尾的函数 clidebug可以以多实例的方式 3.4黑盒子主要用于业务进程异常崩溃时记录现场堆栈信息，为定位问题提供分析依据。 支持的异常信号如下: 信号 类型 SIGSEGV 段错误 SIGFPE 运算错误 SIGILL 非法指令 SIGABRT 终止 SIGBUS 总线访问异常，部分CPU在访问未对齐地址报错 输出内容如下: 异常原因(信号名)。 进程标示(进程pid,进程名) 异常发生时间 异常指令地址，异常访问的非法地址(仅对段错误有效) 寄存器数据，寄存器显示寄存器名字，如EAX,EBX等 异常调用栈，以及函数行号(优先使用dladdr 解析，若dladdr 解析失败，则使用addr2line解析行号) 栈中部分数据 3.5守护进程lte_daemon进程配置文件为cspl_confing.xml， 其功能如下： 启动所有启动类型不为START_BY_SELF的SYS_APP(如lte_log)、USER_APP(业务)进程 等待子进程进入运行状态(最长等待时间: 500 ms * 120)收集所有进程的CSPL_SIG_RUN_SYNC信号，进而判断进程是否已经进入运行态(APP_RUNNING)；并发送CSPL_SIG_RUN_SYNC给所有进程，完成进程状态双向确认。 进程保活(心跳信号)状态监控注册daemonEntity模块监控进程心跳信号，若超出配置3次没有连续接收到心跳信号(CSPL_SIG_KEEPALIVE)，则依据restartMode的配置进行相应处理。 喂狗看门狗使能的前提下创建喂狗线程daemon_feedWatchDog(高优先级线程)， 每隔2 s进行一次喂狗操作：bsp_watchdog_feed(g_daemonConfig.feedDogInternel); 监控所有运行的进程创建监控线程daemon_monitorApp，执行daemon_WaitApp函数，一旦有业务进程退出，依据restartMode的配置采取动作： 重启此进程 重启所有进程 重启系统 忽略不做处理。记录重启进程的次数，当重启次数 &gt; maxRestartNum时， 强制重启系统 lte_daemon中的信号及日志输出 信号 说明 CSPL_SIG_KEEPALIVE 进程保活心跳信号; CSPL_SIG_START_SYNC 进程启动同步信号； 若进程配置项startSync打开，则lte_damon在拉起此进程后，会循环检测此进程的startFinishFlag标志是否置位； 被拉起的进程在启动后通过向lte_damon进程发送CSPL_SIG_START_SYNC信号来置位此标志(CSPL_SendStartSyncAck函数) CSPL_SIG_RUN_SYNC 进程运行同步信号； lte_daemon进程与所拉起的进程在启动后，互相发送此信号，同步双方进程运行状态 CSPL_SIG_DAEMON_REBOOT daemon重启信号； lte_daemon接收到此信号后，调用daemon_reboot()函数重启系统 3.6主备倒换Opensaf简介： Opensaf是一个高可靠性分布式系统中间件，介于操作系统和用户应用层之间，屏蔽下层操作系统接口，向上提供各种服务。 CSPL集成Opensaf Amf作为CSPL进程中的一个线程执行，对业务代码不可见。 CSPL只向业务提供有限的对外API和数据结构来实现Amf功能。 CSPL需要重新封装Amf和checkPoint功能，将两者结合起来使用，使用状态机的方式来处理。 基站主备倒换场景 主控板通过浮动IP与基带板交互，如上图，主控板的浮动IP为10.11.1.130，开始在CB1上设置，当发生主备倒换，CB1上关闭浮动IP，在CB2上设置浮动IP。相应的OAM会通知基带板的薄平台，基带板上有两个网卡，薄平台需要控制始终与当前主用主控板连接的网卡设置同一个IP地址，比如开始时设置的Eth2网卡IP地址为192.168.1.4，此时Eth3关闭，当收到OAM的切换通知，关闭Eth2，在Eth3上设置IP 192.168.1.4。 3.7常用算法CSPL中常用算法库位于目录cspl&#x2F;src&#x2F;core&#x2F;ylib&#x2F;src中： 位图算法位于ylib-bitmap.c文件中；cspl中定时器的超时时间排序使用此算法，用于获取距离当前时间最短的定时器超时时间间隔。 crc算法位于ylib-crc.c文件中；8位、16位、32位crc算法 哈希算法位于ylib-hash.c文件中；根据关键码值(Key value)而直接进行访问的数据结构。即通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。 双链表算法位于ylib-list.c文件中；cspl内部大量使用，如在qvars.modules双链表用于遍历此driver下所有的module信息 单链表算法位于ylib-pool.c文件中；cspl中内存池qpool. list单链表用于链接所有qbuf结构体 优先级队列算法位于ylib-squeue.c文件中；cspl中driver中的接收、发送队列中压入、弹出cspl消息时均使用此算法。 红黑树算法位于ylib-tree.c文件中；一种自平衡二叉查找树，典型的用途是实现关联数组，获得较高的查找性能。cspl中QMODULE qvGetService( unsigned long name )函数使用了此算法，通过对qvcontext. services(YTREE)红黑树遍历来获取name所指向的qmodule结构体指针 3.8数据库基于SQlite数据库。 SQLite是一个嵌入式数据库，和其他嵌入式DB(FastDB, extremeDB) 相比，DML、DDL操作均支持SQL语句，即最终提供给SQLite执行的是一个SQL语句，而不是一个数据结构。 SQlite数据类型：NULL、INTEGER、REAL、TEXT、BLOB基站数据类型：8&#x2F;16&#x2F;32&#x2F;64位有无符号整型、时间&#x2F;IP&#x2F;数组&#x2F;枚举多选&#x2F;密码&#x2F;数据&#x2F;文本类型、枚举&#x2F;布尔型 数据库标识：数据库链接表标识：表名和表ID（映射关系）字段标识：字段名和字段ID（映射关系） 应用程序和DBS的数据传递一条记录的时候，仅仅包括应用指定的字段值。包括以下场景：插入,查询，删除，更新。","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]},{"title":"4G_LTE（一）","slug":"4G-LTE（一）","date":"2023-08-08T07:14:27.000Z","updated":"2023-09-07T09:38:40.357Z","comments":true,"path":"2023/08/08/4G-LTE（一）/","link":"","permalink":"http://example.com/2023/08/08/4G-LTE%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"常用专业术语1.AS与NAS AS：接入层信令，是UE和接入网eUTRAN使用的信令，由基站来处理 L1：物理层 L2：数据链路层 L3：网络层 NAS：非接入层信令，是UE和核心网EPC之间使用的信令，虽然途径接入网eUTRAN，但基站不作分析 传输层、会话层、表示层、应用层 2.LTE 4G LTE一般特指TD-LTE制式网络 4G -&gt; LTE 4G+ -&gt; LTE-A LTE通常分为FDD LTE和TDD LTE TDD，时分双工(Time Division Duplexing) FDD，频分双工(Frequency Division Duplexing) 单工，发送端只能发送，接收端只能接受（广播） 半双工，双方都能发送和接送，但同一时间只能一方发送，一方接收（对讲机） 全双工，可以同时发送和接收（手机） 3G UMTS组网架构分为4层：终端（UE）、基站（NodeB）、无线网络控制器（RNC）、核心网（CN） 4G LTE组网架构分为3层：终端（UE）、基站（eNodeB）、核心网（EPC） 3.RRU与BBU RRU：Radio Remote Unit 射频拉远单元 BBU：Building Baseband Unit 室内基带处理单元 RRU和BBU之间需要用光纤连接。一个BBU可以支持多个RRU。采用BBU+RRU多通道方案，可以很好地解决大型场馆的室内复盖。 基带BBU集中放置在机房，RRU可安装至楼层，BBU与RRU之间采用光纤传输，RRU再通过同轴电缆及功分器(耦合器)等连接至天线，即主干采用光纤，支路采用同轴电缆","categories":[{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"}],"tags":[]}],"categories":[{"name":"工具&教程","slug":"工具-教程","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%99%E7%A8%8B/"},{"name":"储备","slug":"储备","permalink":"http://example.com/categories/%E5%82%A8%E5%A4%87/"},{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[]}